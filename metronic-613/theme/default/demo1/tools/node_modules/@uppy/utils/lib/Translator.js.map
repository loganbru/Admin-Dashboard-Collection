{"version":3,"sources":["Translator.js"],"names":["has","require","module","exports","locales","locale","strings","pluralize","n","Array","isArray","forEach","_apply","prevLocale","interpolate","phrase","options","String","prototype","split","replace","dollarRegex","dollarBillsYall","interpolated","arg","replacement","call","insertReplacement","RegExp","source","rx","newParts","chunk","push","raw","i","list","length","translate","key","translateArray","join","Error","string","hasPluralForms","smart_count","plural"],"mappings":"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","sourcesContent":["const has = require('./hasProperty')\n\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\nmodule.exports = class Translator {\n  /**\n   * @param {object|Array<object>} locales - locale or list of locales.\n   */\n  constructor (locales) {\n    this.locale = {\n      strings: {},\n      pluralize: function (n) {\n        if (n === 1) {\n          return 0\n        }\n        return 1\n      }\n    }\n\n    if (Array.isArray(locales)) {\n      locales.forEach((locale) => this._apply(locale))\n    } else {\n      this._apply(locales)\n    }\n  }\n\n  _apply (locale) {\n    if (!locale || !locale.strings) {\n      return\n    }\n\n    const prevLocale = this.locale\n    this.locale = Object.assign({}, prevLocale, {\n      strings: Object.assign({}, prevLocale.strings, locale.strings)\n    })\n    this.locale.pluralize = locale.pluralize || prevLocale.pluralize\n  }\n\n  /**\n   * Takes a string with placeholder variables like `%{smart_count} file selected`\n   * and replaces it with values from options `{smart_count: 5}`\n   *\n   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n   *\n   * @param {string} phrase that needs interpolation, with placeholders\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {string} interpolated\n   */\n  interpolate (phrase, options) {\n    const { split, replace } = String.prototype\n    const dollarRegex = /\\$/g\n    const dollarBillsYall = '$$$$'\n    let interpolated = [phrase]\n\n    for (const arg in options) {\n      if (arg !== '_' && has(options, arg)) {\n        // Ensure replacement value is escaped to prevent special $-prefixed\n        // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n        // be escaped with \"$\" itself, and we need two in the resulting output.\n        var replacement = options[arg]\n        if (typeof replacement === 'string') {\n          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall)\n        }\n        // We create a new `RegExp` each time instead of using a more-efficient\n        // string replace so that the same argument can be replaced multiple times\n        // in the same phrase.\n        interpolated = insertReplacement(interpolated, new RegExp('%\\\\{' + arg + '\\\\}', 'g'), replacement)\n      }\n    }\n\n    return interpolated\n\n    function insertReplacement (source, rx, replacement) {\n      const newParts = []\n      source.forEach((chunk) => {\n        // When the source contains multiple placeholders for interpolation,\n        // we should ignore chunks that are not strings, because those\n        // can be JSX objects and will be otherwise incorrectly turned into strings.\n        // Without this condition weâ€™d get this: [object Object] hello [object Object] my <button>\n        if (typeof chunk !== 'string') {\n          return newParts.push(chunk)\n        }\n\n        split.call(chunk, rx).forEach((raw, i, list) => {\n          if (raw !== '') {\n            newParts.push(raw)\n          }\n\n          // Interlace with the `replacement` value\n          if (i < list.length - 1) {\n            newParts.push(replacement)\n          }\n        })\n      })\n      return newParts\n    }\n  }\n\n  /**\n   * Public translate method\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used later to replace placeholders in string\n   * @returns {string} translated (and interpolated)\n   */\n  translate (key, options) {\n    return this.translateArray(key, options).join('')\n  }\n\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {Array} The translated and interpolated parts, in order.\n   */\n  translateArray (key, options) {\n    if (!has(this.locale.strings, key)) {\n      throw new Error(`missing string: ${key}`)\n    }\n\n    const string = this.locale.strings[key]\n    const hasPluralForms = typeof string === 'object'\n\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        const plural = this.locale.pluralize(options.smart_count)\n        return this.interpolate(string[plural], options)\n      } else {\n        throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}')\n      }\n    }\n\n    return this.interpolate(string, options)\n  }\n}\n"]}