(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova["default"])()) {
        return (0, _readAsByteArray["default"])(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error("Unknown data type");
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative["default"])() && input && typeof input.uri !== "undefined") {
        return (0, _uriToBlob["default"])(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. " + err);
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === "function" && typeof input.size !== "undefined") {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === "function") {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
    }
  }]);

  return FileReader;
}();

exports["default"] = FileReader;

},{"./isCordova":5,"./isReactNative":6,"./readAsByteArray":7,"./uriToBlob":8}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */


function fingerprint(file, options) {
  if ((0, _isReactNative["default"])()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(["tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint].join("-"));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint].join("/");
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}

},{"./isReactNative":6}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return "XHRHttpStack";
    }
  }]);

  return XHRHttpStack;
}();

exports["default"] = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!("upload" in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function get() {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function get() {
    return _urlStorage.canStoreURLs;
  }
});
Object.defineProperty(exports, "HttpStack", {
  enumerable: true,
  get: function get() {
    return _httpStack["default"];
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread({}, _upload["default"].defaultOptions, {
  httpStack: new _httpStack["default"](),
  fileReader: new _fileReader["default"](),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage["default"](),
  fingerprint: _fingerprint["default"]
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread({}, defaultOptions, {}, options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread({}, defaultOptions, {}, options);
      return _upload["default"].terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload["default"]);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === "function";
exports.isSupported = isSupported;

},{"../logger":11,"../noopUrlStorage":12,"../upload":13,"./fileReader":1,"./fingerprint":2,"./httpStack":3,"./urlStorage":9}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isCordova = function isCordova() {
  return typeof window != "undefined" && (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined");
};

var _default = isCordova;
exports["default"] = _default;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};

var _default = isReactNative;
exports["default"] = _default;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = readAsByteArray;
/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */

function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uriToBlob;
/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */

function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = "blob";

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open("GET", uri);
    xhr.send();
  });
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = "localStorage" in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = "tusSupport";
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries("tus::");

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader("X-Request-ID") || "n/a";
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : "n/a";
      var body = res ? res.getBody() || "" : "n/a";
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports["default"] = _default;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;
/* eslint no-console: "off" */

var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports["default"] = NoopUrlStorage;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _error = _interopRequireDefault(require("./error"));

var _logger = require("./logger");

var _uuid = _interopRequireDefault(require("./uuid"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  onShouldRetry: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ("resume" in options) {
      console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
        this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ["uploadUrl", "uploadSize", "uploadLengthDeferred"].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.");
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        } else {
          return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
        }
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread({}, _this3.options, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread({}, _this3.options.headers, {
                "Upload-Concat": "partial"
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest("POST", _this3.options.endpoint);
        req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" "))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== "") {
          req.setHeader("Upload-Metadata", metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this3._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)("Creating a new upload");

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate, cb) {
      var _this4 = this;

      if (typeof cb === "function") {
        throw new Error("tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead");
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error["default"](message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));

        return;
      }

      var req = this._openRequest("POST", this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader("Upload-Defer-Length", 1);
      } else {
        req.setHeader("Upload-Length", this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== "") {
        req.setHeader("Upload-Metadata", metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this6._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === "function") {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, "tus: failed to create upload", err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest("HEAD", this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader("Upload-Offset"), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, "tus: invalid or missing offset value");

          return;
        }

        var length = parseInt(res.getHeader("Upload-Length"), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, "tus: invalid or missing length value");

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === "function") {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest("POST", this.url);
        req.setHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        req = this._openRequest("PATCH", this.url);
      }

      req.setHeader("Upload-Offset", this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset " + _this8._offset, err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader("Content-Type", "application/offset+octet-stream"); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader("Upload-Length", _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        } else {
          _this9._emitProgress(_this9._offset, _this9._size);

          return _this9._sendRequest(req, value);
        }
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader("Upload-Offset"), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, "tus: invalid or missing offset value");

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return sendRequest(req, body, this.options);
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof options === "function" || typeof cb === "function") {
        throw new Error("tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead");
      }

      var req = openRequest("DELETE", url, options);
      return sendRequest(req, null, options).then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error["default"]("tus: unexpected response while terminating upload", null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error["default"])) {
          err = new _error["default"]("tus: failed to terminate upload", err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread({}, options, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + _jsBase.Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader("Tus-Resumable", "1.0.0");
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid["default"])();
    req.setHeader("X-Request-ID", requestId);
  }

  return req;
}
/**
 * Send a request with the provided body while invoking the onBeforeRequest
 * and onAfterResponse callbacks.
 *
 * @api private
 */


function sendRequest(req, body, options) {
  var onBeforeRequestPromise = typeof options.onBeforeRequest === "function" ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();
  return onBeforeRequestPromise.then(function () {
    return req.send(body).then(function (res) {
      var onAfterResponsePromise = typeof options.onAfterResponse === "function" ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();
      return onAfterResponsePromise.then(function () {
        return res;
      });
    });
  });
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== "undefined" && "navigator" in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or
  // a onShouldRetry is specified and returns true
  // - the browser does not indicate that we are offline
  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {
    return false;
  }

  if (options && typeof options.onShouldRetry === "function") {
    return options.onShouldRetry(err, retryAttempt, options);
  }

  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse["default"](link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports["default"] = _default;

},{"./error":10,"./logger":11,"./uuid":14,"js-base64":47,"url-parse":51}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uuid;
/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */

function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

},{}],15:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":17}],16:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/createError":23,"./../core/settle":26,"./../helpers/buildURL":30,"./../helpers/cookies":32,"./../helpers/isURLSameOrigin":34,"./../helpers/parseHeaders":36,"./../utils":38}],17:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":18,"./cancel/CancelToken":19,"./cancel/isCancel":20,"./core/Axios":21,"./defaults":28,"./helpers/bind":29,"./helpers/spread":37,"./utils":38}],18:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],19:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":18}],20:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],21:[function(require,module,exports){
'use strict';

var defaults = require('./../defaults');
var utils = require('./../utils');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"./../defaults":28,"./../utils":38,"./InterceptorManager":22,"./dispatchRequest":24}],22:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":38}],23:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":25}],24:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var isAbsoluteURL = require('./../helpers/isAbsoluteURL');
var combineURLs = require('./../helpers/combineURLs');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":20,"../defaults":28,"./../helpers/combineURLs":31,"./../helpers/isAbsoluteURL":33,"./../utils":38,"./transformData":27}],25:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

},{}],26:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":23}],27:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":38}],28:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this,require('_process'))

},{"./adapters/http":16,"./adapters/xhr":16,"./helpers/normalizeHeaderName":35,"./utils":38,"_process":44}],29:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],30:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":38}],31:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],32:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);

},{"./../utils":38}],33:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],34:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);

},{"./../utils":38}],35:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":38}],36:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":38}],37:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],38:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');
var isBuffer = require('is-buffer');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":29,"is-buffer":39}],39:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

},{}],40:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":41,"ieee754":42,"isarray":43}],41:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],42:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],43:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],44:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],45:[function(require,module,exports){
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":46}],46:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":44}],47:[function(require,module,exports){
(function (global){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.1";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array = function(a) {
        return btoa(Array.from(a, function(c) {
            return String.fromCharCode(c)
        }).join(''));
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) {
                return m0 == '-' ? '+' : '/'
            }).replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var toUint8Array = function(a) {
        return Uint8Array.from(atob(a), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],48:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],49:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],50:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],51:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":48,"requires-port":50}],52:[function(require,module,exports){
"use strict";

require("regenerator-runtime/runtime");

require("es6-promise/auto");

// The regenerator runtime is needed since the test use functions
// with the async/await keywords. See
// https://babeljs.io/docs/en/babel-plugin-transform-regenerator
// Polyfill `Promise` for Internet Explorer.
// This is a fun piece of code. Let me tell you the story behind it:
// Internet Explorer 10 and 11 have a bug where the event handlers
// for XMLHttpRequests will be invoked with a significant delay after
// the actual request has been finished. So, even if the HTTP request
// only took 1s to complete, IE will wait another 20s before it decides
// to tell your application that the request has been finished. This
// was not a big problem in daily use since this issue did only occur
// when the user did not interact with the webpage, e.g. move the mouse.
// However, when testing in automated browssers, no user interaction was
// occurring.
// Eventually, someone figured out that this was related to a Promise
// polyfill that is used by the axios HTTP client. This solution is
// to use a timeout, as follows, which is enough to cause the network
// delays to vanish.
// Whoever found that patch, I hope they will go to heaven.
// See https://github.com/axios/axios/issues/1862
function t() {
  window.setTimeout(t, 10);
}

t();
beforeEach(function () {
  // Clear localStorage before every test to prevent stored URLs to
  // interfere with our setup.
  localStorage.clear();
});

require("./helpers/puppeteer/reporter.js");

require("./test-common.js");

require("./test-browser-specific.js");

require("./test-parallel-uploads.js");

require("./test-terminate.js");

require("./test-end-to-end.js");

},{"./helpers/puppeteer/reporter.js":54,"./test-browser-specific.js":56,"./test-common.js":57,"./test-end-to-end.js":58,"./test-parallel-uploads.js":59,"./test-terminate.js":60,"es6-promise/auto":45,"regenerator-runtime/runtime":49}],53:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

module.exports = /*#__PURE__*/function () {
  var _assertUrlStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(urlStorage) {
    var result, key1, key2, key3;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return urlStorage.findAllUploads();

          case 2:
            result = _context.sent;
            expect(result).toEqual([]); // Add a few uploads into the storage

            _context.next = 6;
            return urlStorage.addUpload("fingerprintA", {
              id: 1
            });

          case 6:
            key1 = _context.sent;
            _context.next = 9;
            return urlStorage.addUpload("fingerprintA", {
              id: 2
            });

          case 9:
            key2 = _context.sent;
            _context.next = 12;
            return urlStorage.addUpload("fingerprintB", {
              id: 3
            });

          case 12:
            key3 = _context.sent;
            expect(/^tus::fingerprintA::/.test(key1)).toBe(true);
            expect(/^tus::fingerprintA::/.test(key2)).toBe(true);
            expect(/^tus::fingerprintB::/.test(key3)).toBe(true); // Query the just stored uploads individually

            _context.next = 18;
            return urlStorage.findUploadsByFingerprint("fingerprintA");

          case 18:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }]);
            _context.next = 23;
            return urlStorage.findUploadsByFingerprint("fingerprintB");

          case 23:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 3,
              urlStorageKey: key3
            }]); // Check that we can retrieve all stored uploads

            _context.next = 28;
            return urlStorage.findAllUploads();

          case 28:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }, {
              id: 3,
              urlStorageKey: key3
            }]); // Check that it can remove an upload and will not return it back

            _context.next = 33;
            return urlStorage.removeUpload(key2);

          case 33:
            _context.next = 35;
            return urlStorage.removeUpload(key3);

          case 35:
            _context.next = 37;
            return urlStorage.findUploadsByFingerprint("fingerprintA");

          case 37:
            result = _context.sent;
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }]);
            _context.next = 41;
            return urlStorage.findUploadsByFingerprint("fingerprintB");

          case 41:
            result = _context.sent;
            expect(result).toEqual([]);

          case 43:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function assertUrlStorage(_x) {
    return _assertUrlStorage.apply(this, arguments);
  }

  return assertUrlStorage;
}(); // Sort the results from the URL storage since the order in not deterministic.


function sort(result) {
  result.sort(function (a, b) {
    return a.id - b.id;
  });
}

},{}],54:[function(require,module,exports){
"use strict";

/* eslint no-console: 0 */

/* eslint no-unused-vars: 0 */
var testsCompleted = false;
var testsPassed = true; // This reporter is used by bin/puppeteer-jasmine.js to obtain the test results.
// See https://jasmine.github.io/api/edge/Reporter.html for more details on the
// function signatures.

var reporter = {
  jasmineStarted: function jasmineStarted(suiteInfo) {},
  suiteStarted: function suiteStarted(result) {},
  specStarted: function specStarted(result) {},
  specDone: function specDone(result) {
    // Print the test result to the console.
    var passed = result.status === "passed";
    var prefix = passed ? "" : "";
    console.log(prefix, result.fullName);
    testsCompleted = true;
    testsPassed = testsPassed && passed;

    for (var i = 0; i < result.failedExpectations.length; i++) {
      console.log("Failure: " + result.failedExpectations[i].message);
      console.log(result.failedExpectations[i].stack);
      console.log("");
    }
  },
  suiteDone: function suiteDone(result) {},
  jasmineDone: function jasmineDone(result) {
    var success = testsCompleted && testsPassed;

    if (success) {
      console.log("Tests passed!");
    } else {
      console.log("Tests failed!");
    } // The __jasmineCallback function is exposed by the bin/puppeteer-jasmine.js
    // script. See it for more details.


    if (typeof window.__jasmineCallback === "function") {
      window.__jasmineCallback(success);
    }
  }
};
window.jasmine.getEnv().addReporter(reporter);

},{}],55:[function(require,module,exports){
(function (Buffer){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var isBrowser = typeof window !== "undefined";
var isNode = !isBrowser;
/**
 * Obtain a platform specific buffer object, which can be
 * handled by tus-js-client.
 */

function getBlob(str) {
  if (isNode) {
    return Buffer.from(str);
  } else {
    return new Blob(str.split(""));
  }
}
/**
 * Create a promise and obtain the resolve/reject functions
 * outside of the Promise callback.
 */


function flatPromise() {
  var resolveFn;
  var rejectFn;
  var p = new Promise(function (resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return [p, resolveFn, rejectFn];
}
/**
 * Create a spy-able function which resolves a Promise
 * once it is called.
 */


function waitableFunction() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "func";

  var _flatPromise = flatPromise(),
      _flatPromise2 = _slicedToArray(_flatPromise, 2),
      promise = _flatPromise2[0],
      resolve = _flatPromise2[1];

  var fn = jasmine.createSpy(name, resolve).and.callThrough();
  fn.toBeCalled = promise;
  return fn;
}
/**
 * Create a Promise that resolves after the specified duration.
 */


function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay, "timed out");
  });
}
/**
 * TestHttpStack implements the HTTP stack interface for tus-js-client
 * and can be used to assert outgoing requests and respond with mock data.
 */


var TestHttpStack = /*#__PURE__*/function () {
  function TestHttpStack() {
    _classCallCheck(this, TestHttpStack);

    this._pendingRequests = [];
    this._pendingWaits = [];
  }

  _createClass(TestHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      var _this = this;

      return new TestRequest(method, url, function (req) {
        if (_this._pendingWaits.length >= 1) {
          var handler = _this._pendingWaits.shift();

          handler(req);
          return;
        }

        _this._pendingRequests.push(req);
      });
    }
  }, {
    key: "nextRequest",
    value: function nextRequest() {
      var _this2 = this;

      if (this._pendingRequests.length >= 1) {
        return Promise.resolve(this._pendingRequests.shift());
      }

      return new Promise(function (resolve) {
        _this2._pendingWaits.push(resolve);
      });
    }
  }]);

  return TestHttpStack;
}();

var TestRequest = /*#__PURE__*/function () {
  function TestRequest(method, url, onRequestSend) {
    _classCallCheck(this, TestRequest);

    this.method = method;
    this.url = url;
    this.requestHeaders = {};
    this.body = null;
    this._onRequestSend = onRequestSend;

    this._onProgress = function () {};

    var _flatPromise3 = flatPromise();

    var _flatPromise4 = _slicedToArray(_flatPromise3, 3);

    this._requestPromise = _flatPromise4[0];
    this._resolveRequest = _flatPromise4[1];
    this._rejectRequest = _flatPromise4[2];
  }

  _createClass(TestRequest, [{
    key: "getMethod",
    value: function getMethod() {
      return this.method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this.url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this.requestHeaders[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this.requestHeaders[header] || null;
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      this._onProgress = progressHandler;
    }
  }, {
    key: "send",
    value: function send() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.body = body;

      if (body) {
        this._onProgress(0);

        this._onProgress(body.length || body.size || 0);
      }

      this._onRequestSend(this);

      return this._requestPromise;
    }
  }, {
    key: "abort",
    value: function abort() {
      this._rejectRequest(new Error("request aborted"));
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error("not implemented");
    }
  }, {
    key: "respondWith",
    value: function respondWith(resData) {
      resData.responseHeaders = resData.responseHeaders || {};
      var res = new TestResponse(resData);

      this._resolveRequest(res);
    }
  }, {
    key: "responseError",
    value: function responseError(err) {
      this._rejectRequest(err);
    }
  }]);

  return TestRequest;
}();

var TestResponse = /*#__PURE__*/function () {
  function TestResponse(res) {
    _classCallCheck(this, TestResponse);

    this._response = res;
  }

  _createClass(TestResponse, [{
    key: "getStatus",
    value: function getStatus() {
      return this._response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._response.responseHeaders[header];
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._response.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error("not implemented");
    }
  }]);

  return TestResponse;
}();

module.exports = {
  TestHttpStack: TestHttpStack,
  waitableFunction: waitableFunction,
  wait: wait,
  getBlob: getBlob
};

}).call(this,require("buffer").Buffer)

},{"buffer":40}],56:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* global Blob  */
var assertUrlStorage = require("./helpers/assertUrlStorage");

var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait;

var tus = require("../../");

describe("tus", function () {
  beforeEach(function () {
    localStorage.clear();
  });
  describe("#Upload", function () {
    it("should resume an upload from a stored url", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, file, options, upload, previousUploads, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localStorage.setItem("tus::fingerprinted::1337", JSON.stringify({
                uploadUrl: "http://tus.io/uploads/resuming"
              }));
              testStack = new TestHttpStack();
              file = new Blob("hello world".split(""));
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onProgress: function onProgress() {},
                fingerprint: function fingerprint() {}
              };
              spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              _context.next = 9;
              return upload.findPreviousUploads();

            case 9:
              previousUploads = _context.sent;
              expect(previousUploads).toEqual([{
                uploadUrl: "http://tus.io/uploads/resuming",
                urlStorageKey: "tus::fingerprinted::1337"
              }]);
              upload.resumeFromPreviousUpload(previousUploads[0]);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalledWith(file, upload.options);
              _context.next = 16;
              return testStack.nextRequest();

            case 16:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 3
                }
              });
              _context.next = 23;
              return testStack.nextRequest();

            case 23:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(3);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              expect(upload.url).toBe("http://tus.io/uploads/resuming");
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    describe("storing of upload urls", function () {
      var testStack = new TestHttpStack();
      var options = {
        httpStack: testStack,
        endpoint: "http://tus.io/uploads",
        fingerprint: function fingerprint() {}
      };

      var startUpload = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var file, upload, req;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  file = new Blob("hello world".split(""));
                  spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
                  options.onSuccess = waitableFunction("onSuccess");
                  upload = new tus.Upload(file, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalled();
                  _context2.next = 8;
                  return testStack.nextRequest();

                case 8:
                  req = _context2.sent;
                  expect(req.url).toBe("http://tus.io/uploads");
                  expect(req.method).toBe("POST");
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: "/uploads/blargh"
                    }
                  }); // Wait a short delay to allow the Promises to settle

                  _context2.next = 14;
                  return wait(10);

                case 14:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function startUpload() {
          return _ref2.apply(this, arguments);
        };
      }();

      var finishUpload = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var req;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return testStack.nextRequest();

                case 2:
                  req = _context3.sent;
                  expect(req.url).toBe("http://tus.io/uploads/blargh");
                  expect(req.method).toBe("PATCH");
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      "Upload-Offset": 11
                    }
                  });
                  _context3.next = 8;
                  return options.onSuccess.toBeCalled;

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function finishUpload() {
          return _ref3.apply(this, arguments);
        };
      }();

      it("should store and retain with default options", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var key, storedUpload;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options.removeFingerprintOnSuccess = false;
                _context4.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf("tus::fingerprinted::")).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe("http://tus.io/uploads/blargh");
                expect(storedUpload.size).toBe(11);
                _context4.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(JSON.stringify(storedUpload));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      })));
      it("should store and remove with option removeFingerprintOnSuccess set", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var key, storedUpload;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options.removeFingerprintOnSuccess = true;
                _context5.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf("tus::fingerprinted::")).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe("http://tus.io/uploads/blargh");
                expect(storedUpload.size).toBe(11);
                _context5.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(null);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      })));
    });
    it("should delete upload urls on a 4XX", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = new Blob("hello world".split(""));
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                fingerprint: function fingerprint() {}
              };
              spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                uploadUrl: "http://tus.io/uploads/resuming",
                urlStorageKey: "tus::fingerprinted::1337"
              });
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 400
              });
              _context6.next = 15;
              return wait(10);

            case 15:
              expect(localStorage.getItem("tus::fingerprinted::1337")).toBe(null);

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    describe("uploading data from a Reader", function () {
      function makeReader(content) {
        var readSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : content.length;
        var reader = {
          value: content.split(""),
          read: function read() {
            var value,
                done = false;

            if (this.value.length > 0) {
              value = this.value.slice(0, readSize);
              this.value = this.value.slice(readSize);
            } else {
              done = true;
            }

            return Promise.resolve({
              value: value,
              done: done
            });
          },
          cancel: waitableFunction("cancel")
        };
        return reader;
      }

      function assertReaderUpload(_x) {
        return _assertReaderUpload.apply(this, arguments);
      }

      function _assertReaderUpload() {
        _assertReaderUpload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(_ref7) {
          var readSize, chunkSize, reader, testStack, options, upload, req;
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  readSize = _ref7.readSize, chunkSize = _ref7.chunkSize;
                  reader = makeReader("hello world", readSize);
                  testStack = new TestHttpStack();
                  options = {
                    httpStack: testStack,
                    endpoint: "http://tus.io/uploads",
                    chunkSize: chunkSize,
                    onProgress: waitableFunction("onProgress"),
                    onSuccess: waitableFunction("onSuccess"),
                    fingerprint: function fingerprint() {},
                    uploadLengthDeferred: true
                  };
                  spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
                  upload = new tus.Upload(reader, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                  _context14.next = 10;
                  return testStack.nextRequest();

                case 10:
                  req = _context14.sent;
                  expect(req.url).toBe("http://tus.io/uploads");
                  expect(req.method).toBe("POST");
                  expect(req.requestHeaders["Upload-Length"]).toBe(undefined);
                  expect(req.requestHeaders["Upload-Defer-Length"]).toBe(1);
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: "http://tus.io/uploads/blargh"
                    }
                  });
                  _context14.next = 18;
                  return testStack.nextRequest();

                case 18:
                  req = _context14.sent;
                  expect(req.url).toBe("http://tus.io/uploads/blargh");
                  expect(req.method).toBe("PATCH");
                  expect(req.requestHeaders["Upload-Offset"]).toBe(0);
                  expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                  expect(req.body.length).toBe(11);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      "Upload-Offset": 11
                    }
                  });
                  _context14.next = 27;
                  return options.onProgress.toBeCalled;

                case 27:
                  expect(options.onProgress).toHaveBeenCalledWith(11, null);
                  _context14.next = 30;
                  return testStack.nextRequest();

                case 30:
                  req = _context14.sent;
                  expect(req.url).toBe("http://tus.io/uploads/blargh");
                  expect(req.method).toBe("PATCH");
                  expect(req.requestHeaders["Upload-Offset"]).toBe(11);
                  expect(req.requestHeaders["Upload-Length"]).toBe(11);
                  expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                  expect(req.body).toBe(null);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      "Upload-Offset": 11
                    }
                  });
                  _context14.next = 40;
                  return options.onSuccess.toBeCalled;

                case 40:
                  expect(upload.url).toBe("http://tus.io/uploads/blargh");
                  expect(options.onProgress).toHaveBeenCalledWith(11, 11);

                case 42:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));
        return _assertReaderUpload.apply(this, arguments);
      }

      it("should upload data", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 100
                });

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      })));
      it("should read multiple times from the reader", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 6
                });

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      })));
      it("should use multiple PATCH requests", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                reader = makeReader("hello world", 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/uploads",
                  chunkSize: 6,
                  onProgress: waitableFunction("onProgress"),
                  onSuccess: waitableFunction("onSuccess"),
                  fingerprint: function fingerprint() {},
                  uploadLengthDeferred: true
                };
                spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
                upload = new tus.Upload(reader, options);
                upload.start();
                expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                _context9.next = 9;
                return testStack.nextRequest();

              case 9:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads");
                expect(req.method).toBe("POST");
                expect(req.requestHeaders["Upload-Length"]).toBe(undefined);
                expect(req.requestHeaders["Upload-Defer-Length"]).toBe(1);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "http://tus.io/uploads/blargh"
                  }
                });
                _context9.next = 17;
                return testStack.nextRequest();

              case 17:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Offset"]).toBe(0);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body.length).toBe(6);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 6
                  }
                });
                _context9.next = 26;
                return options.onProgress.toBeCalled;

              case 26:
                expect(options.onProgress).toHaveBeenCalledWith(6, null);
                _context9.next = 29;
                return testStack.nextRequest();

              case 29:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
                expect(req.requestHeaders["Upload-Offset"]).toBe(6);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body.length).toBe(5);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context9.next = 39;
                return testStack.nextRequest();

              case 39:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Offset"]).toBe(11);
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body).toBe(null);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context9.next = 49;
                return options.onSuccess.toBeCalled;

              case 49:
                expect(upload.url).toBe("http://tus.io/uploads/blargh");
                expect(options.onProgress).toHaveBeenCalledWith(11, 11);

              case 51:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      })));
      it("should retry the POST request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                reader = makeReader("hello world", 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/files/",
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction("onSuccess"),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context10.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 500
                });
                _context10.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/files/foo"
                  }
                });
                _context10.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context10.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context10.next = 32;
                return options.onSuccess.toBeCalled;

              case 32:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      })));
      it("should retry the first PATCH request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                reader = makeReader("hello world", 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/files/",
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction("onSuccess"),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context11.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/files/foo"
                  }
                });
                _context11.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 500
                });
                _context11.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("HEAD");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 0
                  }
                });
                _context11.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context11.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context11.next = 38;
                return options.onSuccess.toBeCalled;

              case 38:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      })));
      it("should retry following PATCH requests", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                reader = makeReader("hello world there!");
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/files/",
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context12.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/files/foo"
                  }
                });
                _context12.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 6
                  }
                });
                _context12.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 500
                });
                _context12.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("HEAD");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 6
                  }
                });
                _context12.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 12
                  }
                });
                _context12.next = 37;
                return testStack.nextRequest();

              case 37:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 18
                  }
                });
                _context12.next = 43;
                return testStack.nextRequest();

              case 43:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Length"]).toBe(18);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 18
                  }
                });
                _context12.next = 50;
                return options.onSuccess.toBeCalled;

              case 50:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      })));
      it("should cancel the reader when aborted", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var reader, options, upload;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                reader = makeReader("hello there world");
                options = {
                  httpStack: new TestHttpStack(),
                  endpoint: "http://tus.io/files/",
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start(); // We wait until the first request arrives, so that the first promises have resolved.

                _context13.next = 6;
                return options.httpStack.nextRequest();

              case 6:
                upload.abort();
                _context13.next = 9;
                return reader.cancel.toBeCalled;

              case 9:
                expect(reader.cancel).toHaveBeenCalled();

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      })));
    });
    describe("resolving of URIs", function () {
      // Disable these tests for IE 10 and 11 because it's not possible to overwrite
      // the navigator.product property.
      var isIE = navigator.userAgent.indexOf("Trident/") > 0;

      if (isIE) {
        console.log("Skipping tests for React Native in Internet Explorer"); // eslint-disable-line no-console

        return;
      }

      var originalProduct = navigator.product;
      beforeEach(function () {
        jasmine.Ajax.install(); // Simulate React Native environment to enable URIs as input objects.

        Object.defineProperty(navigator, "product", {
          value: "ReactNative",
          configurable: true
        });
      });
      afterEach(function () {
        jasmine.Ajax.uninstall();
        Object.defineProperty(navigator, "product", {
          value: originalProduct,
          configurable: true
        });
      });
      it("should upload a file from an URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var file, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                file = {
                  uri: "file:///my/file.dat"
                };
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/uploads",
                  onSuccess: waitableFunction("onSuccess")
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context15.next = 7;
                return wait(0);

              case 7:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe("file:///my/file.dat");
                expect(req.method).toBe("GET");
                expect(req.responseType).toBe("blob");
                req.respondWith({
                  status: 200,
                  responseHeaders: {
                    "Upload-Length": 11,
                    "Upload-Offset": 3
                  },
                  response: new Blob("hello world".split(""))
                });
                _context15.next = 14;
                return testStack.nextRequest();

              case 14:
                req = _context15.sent;
                expect(req.url).toBe("http://tus.io/uploads");
                expect(req.method).toBe("POST");
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/uploads/blargh"
                  }
                });
                _context15.next = 21;
                return testStack.nextRequest();

              case 21:
                req = _context15.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
                expect(req.requestHeaders["Upload-Offset"]).toBe(0);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body.size).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context15.next = 31;
                return options.onSuccess.toBeCalled;

              case 31:
                expect(upload.url).toBe("http://tus.io/uploads/blargh");

              case 32:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      })));
      it("should emit an error if it can't resolve the URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var file, options, upload, req;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                file = {
                  uri: "file:///my/file.dat"
                };
                options = {
                  endpoint: "http://tus.io/uploads",
                  onError: waitableFunction("onError")
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context16.next = 6;
                return wait(0);

              case 6:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe("file:///my/file.dat");
                expect(req.method).toBe("GET");
                expect(req.responseType).toBe("blob");
                req.responseError();
                _context16.next = 13;
                return options.onError.toBeCalled;

              case 13:
                expect(options.onError).toHaveBeenCalledWith(new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. [object Object]"));

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      })));
    });
  });
  describe("#LocalStorageUrlStorage", function () {
    it("should allow storing and retrieving uploads", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return assertUrlStorage(tus.defaultOptions.urlStorage);

            case 2:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
  });
});

},{"../../":4,"./helpers/assertUrlStorage":53,"./helpers/utils":55}],57:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require("../../"); // Uncomment to enable debug log from tus-js-client
//tus.enableDebugLog();


describe("tus", function () {
  describe("#isSupported", function () {
    it("should be true", function () {
      expect(tus.isSupported).toBe(true);
    });
  });
  describe("#Upload", function () {
    it("should throw if no error handler is available", function () {
      var upload = new tus.Upload(null);
      expect(upload.start.bind(upload)).toThrowError("tus: no file or stream to upload provided");
    });
    it("should throw if no endpoint and upload URL is provided", function () {
      var file = getBlob("hello world");
      var upload = new tus.Upload(file);
      expect(upload.start.bind(upload)).toThrowError("tus: neither an endpoint or an upload URL is provided");
    });
    it("should upload a file", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "https://tus.io/uploads",
                headers: {
                  Custom: "blargh"
                },
                metadata: {
                  foo: "hello",
                  bar: "world",
                  nonlatin: "soce",
                  number: 100
                },
                withCredentials: true,
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11); //if (isBrowser) expect(req.withCredentials).toBe(true);

              expect(req.requestHeaders["Upload-Metadata"]).toBe("foo aGVsbG8=,bar d29ybGQ=,nonlatin c8WCb8WEY2U=,number MTAw");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/blargh"
                }
              });
              _context.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11); //if (isBrowser) expect(req.withCredentials).toBe(true);

              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context.next = 29;
              return options.onSuccess.toBeCalled;

            case 29:
              expect(upload.url).toBe("https://tus.io/uploads/blargh");
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it("should create an upload if resuming fails", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/uploads/resuming"
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 404
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11); // The upload URL should be cleared when tus-js.client tries to create a new upload.

              expect(upload.url).toBe(null);

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it("should create an upload using the creation-with-data extension", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadDataDuringCreation: true,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onProgress");
              spyOn(options, "onChunkComplete");
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh",
                  "Upload-Offset": 11
                }
              });
              _context3.next = 19;
              return options.onSuccess.toBeCalled;

            case 19:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(11, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();
              expect(upload.url).toBe("http://tus.io/uploads/blargh");

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it("should create an upload with partial data and continue", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadDataDuringCreation: true,
                chunkSize: 6,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onProgress");
              spyOn(options, "onChunkComplete");
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context4.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh",
                  "Upload-Offset": 6
                }
              });
              _context4.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context4.sent;
              // Once the second request has been sent, the progress handler must have been invoked.
              expect(options.onProgress).toHaveBeenCalledWith(6, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(6, 6, 11);
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(upload.url).toBe("http://tus.io/uploads/blargh");
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(6);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh",
                  "Upload-Offset": 11
                }
              });
              _context4.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(5, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 36:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    it("should add the request's body and ID to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var testStack, file, options, upload, req, reqId, err;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                addRequestId: true,
                retryDelays: null,
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context5.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context5.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              reqId = req.requestHeaders["X-Request-ID"];
              expect(_typeof(reqId)).toBe("string");
              expect(reqId.length).toBe(36);
              req.respondWith({
                status: 500,
                responseText: "server_error"
              });
              _context5.next = 16;
              return options.onError.toBeCalled;

            case 16:
              err = _context5.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: server_error, request id: " + reqId + ")");
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();

            case 20:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
    it("should invoke the request and response callbacks", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                uploadUrl: "http://tus.io/uploads/foo",
                onBeforeRequest: function onBeforeRequest(req) {
                  expect(req.getURL()).toBe("http://tus.io/uploads/foo");
                  expect(req.getMethod()).toBe("HEAD");
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  expect(req.getURL()).toBe("http://tus.io/uploads/foo");
                  expect(req.getMethod()).toBe("HEAD");
                  expect(res.getStatus()).toBe(204);
                  expect(res.getHeader("Upload-Offset")).toBe(11);
                },
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onBeforeRequest");
              spyOn(options, "onAfterResponse");
              upload = new tus.Upload(file, options);
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe("http://tus.io/uploads/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11,
                  "Upload-Length": 11
                }
              });
              _context6.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    it("should throw an error if resuming fails and no endpoint is provided", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                uploadUrl: "http://tus.io/uploads/resuming",
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context7.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context7.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 404
              });
              _context7.next = 14;
              return options.onError.toBeCalled;

            case 14:
              err = _context7.sent;
              expect(err.message).toBe("tus: unable to resume upload (new upload cannot be created without an endpoint), originated from request (method: HEAD, url: http://tus.io/uploads/resuming, response code: 404, response text: , request id: n/a)");

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    it("should resolve relative URLs", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io:1080/files/"
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context8.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context8.sent;
              expect(req.url).toBe("http://tus.io:1080/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "//localhost/uploads/foo"
                }
              });
              _context8.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context8.sent;
              expect(req.url).toBe("http://localhost/uploads/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              expect(upload.url).toBe("http://localhost/uploads/foo");

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    })));
    it("should upload a file in chunks", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                chunkSize: 7,
                onSuccess: waitableFunction("onSuccess"),
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {}
              };
              spyOn(options, "onProgress");
              spyOn(options, "onChunkComplete");
              upload = new tus.Upload(file, options);
              upload.start();
              _context9.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context9.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/uploads/blargh"
                }
              });
              _context9.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context9.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(7);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 7
                }
              });
              _context9.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context9.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(7);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(4);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context9.next = 37;
              return options.onSuccess.toBeCalled;

            case 37:
              expect(upload.url).toBe("http://tus.io/uploads/blargh");
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(7, 7, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(4, 11, 11);

            case 41:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    })));
    it("should add the original request to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                retryDelays: null,
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context10.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context10.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500,
                responseHeaders: {
                  Custom: "blargh"
                }
              });
              _context10.next = 13;
              return options.onError.toBeCalled;

            case 13:
              err = _context10.sent;
              expect(upload.url).toBe(null);
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: , request id: n/a)");
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();
              expect(err.originalResponse.getHeader("Custom")).toBe("blargh");

            case 19:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    })));
    it("should only create an upload for empty files", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onSuccess: waitableFunction("onSuccess")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context11.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context11.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(0);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "http://tus.io/uploads/empty"
                }
              });
              _context11.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onSuccess).toHaveBeenCalled();

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    })));
    it("should not resume a finished upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction("onSuccess"),
                uploadUrl: "http://tus.io/uploads/resuming"
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context12.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context12.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": "11",
                  "Upload-Offset": "11"
                }
              });
              _context12.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    })));
    it("should resume an upload from a specified url", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/files/upload",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction("onSuccess"),
                fingerprint: function fingerprint() {}
              };
              spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalled();
              _context13.next = 10;
              return testStack.nextRequest();

            case 10:
              req = _context13.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 3
                }
              });
              _context13.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context13.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(3);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context13.next = 27;
              return options.onSuccess.toBeCalled;

            case 27:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(upload.url).toBe("http://tus.io/files/upload");

            case 29:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    })));
    it("should resume a previously started upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onSuccess: waitableFunction("onSuccess"),
                onError: function onError() {}
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context14.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh"
                }
              });
              _context14.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              upload.abort();
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              upload.start();
              _context14.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5,
                  "Upload-Length": 11
                }
              });
              _context14.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context14.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onSuccess).toHaveBeenCalled();

            case 34:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    })));
    it("should override the PATCH method", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/files/upload",
                overridePatchMethod: true
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context15.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context15.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 3
                }
              });
              _context15.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context15.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(3);
              expect(req.requestHeaders["X-HTTP-Method-Override"]).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });

            case 21:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    })));
    it("should emit an error if an upload is locked", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/files/upload",
                onError: waitableFunction("onError"),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context16.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context16.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 423 // Locked

              });
              _context16.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error("tus: upload is currently locked; retry later, originated from request (method: HEAD, url: http://tus.io/files/upload, response code: 423, response text: , request id: n/a)"));

            case 14:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    })));
    it("should emit an error if no Location header is presented", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onError: waitableFunction("onError"),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context17.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context17.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST"); // The Location header is omitted on purpose here

              req.respondWith({
                status: 201
              });
              _context17.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error("tus: invalid or missing Location header, originated from request (method: POST, url: http://tus.io/uploads, response code: 201, response text: , request id: n/a)"));

            case 14:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
    it("should throw if retryDelays is not an array", function () {
      var file = getBlob("hello world");
      var upload = new tus.Upload(file, {
        endpoint: "http://endpoint/",
        retryDelays: 44
      });
      expect(upload.start.bind(upload)).toThrowError("tus: the `retryDelays` option must either be an array or null");
    }); // This tests ensures that tus-js-client correctly retries if the
    // response has the code 500 Internal Error, 423 Locked or 409 Conflict.

    it("should retry the upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction("onSuccess")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context18.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500
              });
              _context18.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context18.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 423
              });
              _context18.next = 25;
              return testStack.nextRequest();

            case 25:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context18.next = 31;
              return testStack.nextRequest();

            case 31:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 409
              });
              _context18.next = 37;
              return testStack.nextRequest();

            case 37:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context18.next = 43;
              return testStack.nextRequest();

            case 43:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context18.next = 49;
              return options.onSuccess.toBeCalled;

            case 49:
              expect(options.onSuccess).toHaveBeenCalled();

            case 50:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18);
    }))); // This tests ensures that tus-js-client correctly retries if the
    // return value of onShouldRetry is true.

    it("should retry the upload when onShouldRetry specified and returns true", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
      var testStack, file, options, upload, req, error;
      return regeneratorRuntime.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction("onSuccess"),
                onShouldRetry: function onShouldRetry() {
                  return true;
                }
              };
              spyOn(options, "onShouldRetry").and.callThrough();
              spyOn(tus.Upload.prototype, "_emitError").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context19.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500
              });
              _context19.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context19.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 423
              });
              _context19.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context19.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 409
              });
              _context19.next = 39;
              return testStack.nextRequest();

            case 39:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context19.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context19.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context19.next = 51;
              return options.onSuccess.toBeCalled;

            case 51:
              expect(options.onSuccess).toHaveBeenCalled();
              error = upload._emitError.calls.argsFor(0)[0];
              expect(options.onShouldRetry).toHaveBeenCalled();
              expect(options.onShouldRetry.calls.argsFor(0)).toEqual([error, 0, upload.options]);
              error = upload._emitError.calls.argsFor(1)[0];
              expect(options.onShouldRetry.calls.argsFor(1)).toEqual([error, 1, upload.options]);

            case 57:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }))); // This tests ensures that tus-js-client correctly aborts if the
    // return value of onShouldRetry is false.

    it("should not retry the upload when callback specified and returns false", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction("onSuccess"),
                onError: waitableFunction("onError"),
                onShouldRetry: function onShouldRetry() {
                  return false;
                }
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context20.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context20.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST"); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context20.next = 14;
              return options.onError.toBeCalled;

            case 14:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 16:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20);
    })));
    it("should not retry if the error has not been caused by a request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
      var file, options, upload, error;
      return regeneratorRuntime.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              file = getBlob("hello world");
              options = {
                httpStack: new TestHttpStack(),
                endpoint: "http://tus.io/files/",
                retryDelays: [10, 10, 10],
                onSuccess: function onSuccess() {},
                onError: function onError() {}
              };
              spyOn(options, "onSuccess");
              spyOn(options, "onError");
              upload = new tus.Upload(file, options);
              spyOn(upload, "_createUpload");
              upload.start();
              _context21.next = 9;
              return wait(200);

            case 9:
              error = new Error("custom error");

              upload._emitError(error);

              expect(upload._createUpload).toHaveBeenCalledTimes(1);
              expect(options.onError).toHaveBeenCalledWith(error);
              expect(options.onSuccess).not.toHaveBeenCalled();

            case 14:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    })));
    it("should stop retrying after all delays have been used", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10],
                onSuccess: function onSuccess() {},
                onError: waitableFunction("onError")
              };
              spyOn(options, "onSuccess");
              upload = new tus.Upload(file, options);
              upload.start();
              _context22.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context22.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500
              });
              _context22.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context22.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST"); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context22.next = 21;
              return options.onError.toBeCalled;

            case 21:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 23:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    })));
    it("should stop retrying when the abort function is called", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10],
                onError: function onError() {}
              };
              spyOn(options, "onError");
              upload = new tus.Upload(file, options);
              upload.start();
              _context23.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context23.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              spyOn(upload, "start").and.callThrough();
              upload.abort();
              req.respondWith({
                status: 500
              });
              _context23.next = 16;
              return Promise.race([testStack.nextRequest(), wait(100)]);

            case 16:
              result = _context23.sent;
              expect(result).toBe("timed out");

            case 18:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    })));
    it("should stop upload when the abort function is called during a callback", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  upload.abort();
                }
              };
              spyOn(options, "onChunkComplete").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context24.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context24.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context24.next = 20;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 20:
              result = _context24.sent;
              expect(options.onChunkComplete).toHaveBeenCalled();
              expect(result).toBe("timed out");

            case 23:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    })));
    it("should stop upload when the abort function is called during the POST request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                onError: function onError() {}
              };
              spyOn(options, "onError").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context25.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context25.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              upload.abort();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context25.next = 15;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 15:
              result = _context25.sent;
              expect(options.onError).not.toHaveBeenCalled();
              expect(result).toBe("timed out");

            case 18:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25);
    })));
    it("should reset the attempt counter if an upload proceeds", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10],
                onError: function onError() {},
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onError");
              upload = new tus.Upload(file, options);
              upload.start();
              _context26.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context26.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 500
              });
              _context26.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context26.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context26.next = 32;
              return testStack.nextRequest();

            case 32:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 500
              });
              _context26.next = 38;
              return testStack.nextRequest();

            case 38:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5,
                  "Upload-Length": 11
                }
              });
              _context26.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context26.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context26.next = 50;
              return options.onSuccess.toBeCalled;

            case 50:
              expect(options.onError).not.toHaveBeenCalled();
              expect(options.onSuccess).toHaveBeenCalled();

            case 52:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26);
    })));
  });
});

},{"../../":4,"./helpers/utils":55}],58:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require("./helpers/utils"),
    getBlob = _require.getBlob;

var tus = require("../../");

var axios = require("axios"); // Test timeout for end-to-end tests when uploading to real server.


var END_TO_END_TIMEOUT = 20 * 1000;
describe("tus", function () {
  describe("end-to-end", function () {
    it("should upload to a real tus server", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob("hello world");
                var options = {
                  endpoint: "https://master.tus.io/files/",
                  metadata: {
                    nonlatin: "soce",
                    number: 100,
                    filename: "hello.txt",
                    filetype: "text/plain"
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/master\.tus\.io\/files\//);
                    console.log("Upload URL:", upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent).then(function (upload) {
                return upload.abort(true).then(function () {
                  return upload;
                });
              }).then(validateUploadDeletion));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), END_TO_END_TIMEOUT);
    it("should upload to a real tus server with creation-with-upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob("hello world");
                var options = {
                  endpoint: "https://master.tus.io/files/",
                  metadata: {
                    nonlatin: "soce",
                    number: 100,
                    filename: "hello.txt",
                    filetype: "text/plain"
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/master\.tus\.io\/files\//);
                    console.log("Upload URL:", upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })), END_TO_END_TIMEOUT);
  });
});

function validateUploadContent(upload) {
  return axios.get(upload.url).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe("hello world");
    return validateUploadMetadata(upload);
  });
}

function validateUploadMetadata(upload) {
  return axios.head(upload.url, {
    headers: {
      "Tus-Resumable": "1.0.0"
    }
  }).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe("");
    expect(res.headers["tus-resumable"]).toBe("1.0.0");
    expect(res.headers["upload-offset"]).toBe("11");
    expect(res.headers["upload-length"]).toBe("11"); // The values in the Upload-Metadata header may not be in the same
    // order as we submitted them (the specification does not require
    // that). Therefore, we split the values and verify that each one
    // is present.

    var metadataStr = res.headers["upload-metadata"];
    expect(metadataStr).toBeTruthy();
    var metadata = metadataStr.split(",");
    expect(metadata).toContain("filename aGVsbG8udHh0");
    expect(metadata).toContain("filetype dGV4dC9wbGFpbg==");
    expect(metadata).toContain("nonlatin c8WCb8WEY2U=");
    expect(metadata).toContain("number MTAw");
    expect(metadata.length).toBe(4);
    return upload;
  });
}

function validateUploadDeletion(upload) {
  var validateStatus = function validateStatus(status) {
    return status === 404;
  };

  return axios.get(upload.url, {
    validateStatus: validateStatus
  }).then(function (res) {
    expect(res.status).toBe(404);
    return upload;
  });
}

},{"../../":4,"./helpers/utils":55,"axios":15}],59:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require("../../");

describe("tus", function () {
  describe("parallel uploading", function () {
    it("should throw if incompatible options are used", function () {
      var file = getBlob("hello world");
      var upload = new tus.Upload(file, {
        endpoint: "https://tus.io/uploads",
        parallelUploads: 2,
        uploadUrl: "foo"
      });
      expect(upload.start.bind(upload)).toThrowError("tus: cannot use the uploadUrl option when parallelUploads is enabled");
    });
    it("should split a file into multiple parts and create an upload for each", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, testUrlStorage, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe("fingerprinted");
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(["https://tus.io/uploads/upload1", "https://tus.io/uploads/upload2"]);
                  return Promise.resolve("tus::fingerprinted::1337");
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe("tus::fingerprinted::1337");
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, "removeUpload").and.callThrough();
              spyOn(testUrlStorage, "addUpload").and.callThrough();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                parallelUploads: 2,
                retryDelays: [10],
                endpoint: "https://tus.io/uploads",
                headers: {
                  Custom: "blargh"
                },
                metadata: {
                  foo: "hello"
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve("fingerprinted");
                }
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(5);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload1"
                }
              });
              _context.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(6);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload2"
                }
              });
              _context.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(6); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 0
                }
              });
              _context.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 6
                }
              });
              _context.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBeUndefined();
              expect(req.requestHeaders["Upload-Concat"]).toBe("final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2");
              expect(req.requestHeaders["Upload-Metadata"]).toBe("foo aGVsbG8=");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "https://tus.io/uploads/upload3"
                }
              });
              _context.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe("https://tus.io/uploads/upload3");
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it("should emit error from a partial upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                retryDelays: null,
                endpoint: "https://tus.io/uploads",
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(5);
              req.respondWith({
                status: 500
              });
              _context2.next = 15;
              return options.onError.toBeCalled;

            case 15:
              err = _context2.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: https://tus.io/uploads, response code: 500, response text: , request id: n/a)");
              expect(err.originalRequest).toBe(req);

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it("should resume the partial uploads", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                // The client should resume the parallel uploads, even if it is not
                // configured for new uploads.
                parallelUploads: 1,
                endpoint: "https://tus.io/uploads",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                urlStorageKey: "tus::fingerprint::1337",
                parallelUploadUrls: ["https://tus.io/uploads/upload1", "https://tus.io/uploads/upload2"]
              });
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 5,
                  "Upload-Offset": 2
                }
              });
              _context3.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 6,
                  "Upload-Offset": 0
                }
              });
              _context3.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("PATCH");
              expect(req.body.size).toBe(3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context3.next = 28;
              return testStack.nextRequest();

            case 28:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("PATCH");
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 6
                }
              });
              _context3.next = 35;
              return testStack.nextRequest();

            case 35:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Upload-Concat"]).toBe("final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "https://tus.io/uploads/upload3"
                }
              });
              _context3.next = 42;
              return options.onSuccess.toBeCalled;

            case 42:
              expect(upload.url).toBe("https://tus.io/uploads/upload3");
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 45:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it("should abort all partial uploads and resume from them", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, file, options, upload, req, req1, req2, reqPromise, result;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                endpoint: "https://tus.io/uploads",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve("fingerprinted");
                }
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(5);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload1"
                }
              });
              _context4.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(6);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload2"
                }
              });
              _context4.next = 28;
              return testStack.nextRequest();

            case 28:
              req1 = _context4.sent;
              expect(req1.url).toBe("https://tus.io/uploads/upload1");
              expect(req1.method).toBe("PATCH");
              expect(req1.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req1.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req1.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req1.body.size).toBe(5);
              _context4.next = 37;
              return testStack.nextRequest();

            case 37:
              req2 = _context4.sent;
              expect(req2.url).toBe("https://tus.io/uploads/upload2");
              expect(req2.method).toBe("PATCH");
              expect(req2.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req2.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req2.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req2.body.size).toBe(6);
              upload.abort();
              req1.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              req2.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 6
                }
              }); // No further requests should be sent.

              reqPromise = testStack.nextRequest();
              _context4.next = 50;
              return Promise.race([reqPromise, wait(100)]);

            case 50:
              result = _context4.sent;
              expect(result).toBe("timed out"); // Restart the upload

              upload.start(); // Reuse the promise from before as it is not cancelled.

              _context4.next = 55;
              return reqPromise;

            case 55:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 5,
                  "Upload-Offset": 5
                }
              });
              _context4.next = 61;
              return testStack.nextRequest();

            case 61:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 6,
                  "Upload-Offset": 6
                }
              });
              _context4.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBeUndefined();
              expect(req.requestHeaders["Upload-Concat"]).toBe("final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "https://tus.io/uploads/upload3"
                }
              });
              _context4.next = 76;
              return options.onSuccess.toBeCalled;

            case 76:
              expect(upload.url).toBe("https://tus.io/uploads/upload3");
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 79:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../../":4,"./helpers/utils":55}],60:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* global expectAsync */
var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    getBlob = _require.getBlob;

var tus = require("../../");

describe("tus", function () {
  describe("terminate upload", function () {
    it("should terminate upload when abort is called with true", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var abortPromise, testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, "onChunkComplete").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 204
              });
              expect(options.onChunkComplete).toHaveBeenCalled();
              _context.next = 27;
              return abortPromise;

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it("should retry terminate when an error is returned on first try", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var abortPromise, testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                chunkSize: 5,
                retryDelays: [10, 10, 10],
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, "onChunkComplete").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context2.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 423
              });
              _context2.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 204
              });
              _context2.next = 32;
              return abortPromise;

            case 32:
              expect(options.onChunkComplete).toHaveBeenCalled();

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it("should stop retrying when all delays are used up", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, options, terminatePromise, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                retryDelays: [10, 10]
              };
              terminatePromise = tus.Upload.terminate("http://tus.io/files/foo", options);
              _context3.next = 5;
              return testStack.nextRequest();

            case 5:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 500
              });
              _context3.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 500
              });
              _context3.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 500
              });
              _context3.next = 23;
              return expectAsync(terminatePromise).toBeRejectedWithError(/tus: unexpected response while terminating upload/);

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it("should invoke the request and response Promises", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, options, terminatePromise, req;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                onBeforeRequest: function onBeforeRequest(req) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe("http://tus.io/uploads/foo");
                    expect(req.getMethod()).toBe("DELETE");
                    resolve();
                  });
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe("http://tus.io/uploads/foo");
                    expect(req.getMethod()).toBe("DELETE");
                    expect(res.getStatus()).toBe(204);
                    resolve();
                  });
                }
              };
              spyOn(options, "onBeforeRequest");
              spyOn(options, "onAfterResponse");
              terminatePromise = tus.Upload.terminate("http://tus.io/uploads/foo", options);
              _context4.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context4.sent;
              expect(req.url).toBe("http://tus.io/uploads/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 204
              });
              _context4.next = 13;
              return expectAsync(terminatePromise).toBeResolved();

            case 13:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 15:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../../":4,"./helpers/utils":55}]},{},[52])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsImxpYi5lczUvYnJvd3Nlci9maW5nZXJwcmludC5qcyIsImxpYi5lczUvYnJvd3Nlci9odHRwU3RhY2suanMiLCJsaWIuZXM1L2Jyb3dzZXIvaW5kZXguanMiLCJsaWIuZXM1L2Jyb3dzZXIvaXNDb3Jkb3ZhLmpzIiwibGliLmVzNS9icm93c2VyL2lzUmVhY3ROYXRpdmUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvcmVhZEFzQnl0ZUFycmF5LmpzIiwibGliLmVzNS9icm93c2VyL3VyaVRvQmxvYi5qcyIsImxpYi5lczUvYnJvd3Nlci91cmxTdG9yYWdlLmpzIiwibGliLmVzNS9lcnJvci5qcyIsImxpYi5lczUvbG9nZ2VyLmpzIiwibGliLmVzNS9ub29wVXJsU3RvcmFnZS5qcyIsImxpYi5lczUvdXBsb2FkLmpzIiwibGliLmVzNS91dWlkLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3Mvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9hdXRvLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCJ0ZXN0L3NwZWMvYnJvd3Nlci1pbmRleC5qcyIsInRlc3Qvc3BlYy9oZWxwZXJzL2Fzc2VydFVybFN0b3JhZ2UuanMiLCJ0ZXN0L3NwZWMvaGVscGVycy9wdXBwZXRlZXIvcmVwb3J0ZXIuanMiLCJ0ZXN0L3NwZWMvaGVscGVycy91dGlscy5qcyIsInRlc3Qvc3BlYy90ZXN0LWJyb3dzZXItc3BlY2lmaWMuanMiLCJ0ZXN0L3NwZWMvdGVzdC1jb21tb24uanMiLCJ0ZXN0L3NwZWMvdGVzdC1lbmQtdG8tZW5kLmpzIiwidGVzdC9zcGVjL3Rlc3QtcGFyYWxsZWwtdXBsb2Fkcy5qcyIsInRlc3Qvc3BlYy90ZXN0LXRlcm1pbmF0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQUVBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQzNDLEVBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0EsT0FBTyxXQUFQLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsSUFBSSxjQUFjLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdHBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TyxDQUFDLGVBQVQsQ0FBTixDQUFnQyxnQkFBaEM7QUFDQSxjQUFBLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBVCxDQUFOLENBQWdDLGdCQUFoQzs7QUFuQ29EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQXBELEdBQUY7QUFxQ0QsR0EzTE8sQ0FBUjtBQTRMRCxDQTdMTyxDQUFSIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2lzUmVhY3ROYXRpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzUmVhY3ROYXRpdmVcIikpO1xuXG52YXIgX3VyaVRvQmxvYiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXJpVG9CbG9iXCIpKTtcblxudmFyIF9pc0NvcmRvdmEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzQ29yZG92YVwiKSk7XG5cbnZhciBfcmVhZEFzQnl0ZUFycmF5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWFkQXNCeXRlQXJyYXlcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBGaWxlU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gTWFrZSB0aGlzLnNpemUgYSBtZXRob2RcbiAgZnVuY3Rpb24gRmlsZVNvdXJjZShmaWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVTb3VyY2UpO1xuXG4gICAgdGhpcy5fZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5zaXplID0gZmlsZS5zaXplO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVTb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIEluIEFwYWNoZSBDb3Jkb3ZhIGFwcGxpY2F0aW9ucywgYSBGaWxlIG11c3QgYmUgcmVzb2x2ZWQgdXNpbmdcbiAgICAgIC8vIEZpbGVSZWFkZXIgaW5zdGFuY2VzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vY29yZG92YS5hcGFjaGUub3JnL2RvY3MvZW4vOC54L3JlZmVyZW5jZS9jb3Jkb3ZhLXBsdWdpbi1maWxlL2luZGV4Lmh0bWwjcmVhZC1hLWZpbGVcbiAgICAgIGlmICgoMCwgX2lzQ29yZG92YS5kZWZhdWx0KSgpKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3JlYWRBc0J5dGVBcnJheS5kZWZhdWx0KSh0aGlzLl9maWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkgey8vIE5vdGhpbmcgdG8gZG8gaGVyZSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcy5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVNvdXJjZTtcbn0oKTtcblxudmFyIFN0cmVhbVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0cmVhbVNvdXJjZShyZWFkZXIsIGNodW5rU2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJlYW1Tb3VyY2UpO1xuXG4gICAgdGhpcy5fY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgIHRoaXMuX2J1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSAwO1xuICAgIHRoaXMuX3JlYWRlciA9IHJlYWRlcjtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RyZWFtU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoc3RhcnQgPCB0aGlzLl9idWZmZXJPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3RlZCBkYXRhIGlzIGJlZm9yZSB0aGUgcmVhZGVyJ3MgY3VycmVudCBvZmZzZXRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGhhc0Vub3VnaERhdGEgPSBlbmQgPD0gdGhpcy5fYnVmZmVyT2Zmc2V0ICsgbGVuKHRoaXMuX2J1ZmZlcik7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lIHx8IGhhc0Vub3VnaERhdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgdmFyIGRvbmUgPSB2YWx1ZSA9PSBudWxsID8gdGhpcy5fZG9uZSA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZG9uZTogZG9uZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgICAgICAgZG9uZSA9IF9yZWYuZG9uZTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIF90aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5fYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpcy5fYnVmZmVyID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IGNvbmNhdChfdGhpcy5fYnVmZmVyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERhdGFGcm9tQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREYXRhRnJvbUJ1ZmZlcihzdGFydCwgZW5kKSB7XG4gICAgICAvLyBSZW1vdmUgZGF0YSBmcm9tIGJ1ZmZlciBiZWZvcmUgYHN0YXJ0YC5cbiAgICAgIC8vIERhdGEgbWlnaHQgYmUgcmVyZWFkIGZyb20gdGhlIGJ1ZmZlciBpZiBhbiB1cGxvYWQgZmFpbHMsIHNvIHdlIGNhbiBvbmx5XG4gICAgICAvLyBzYWZlbHkgZGVsZXRlIGRhdGEgd2hlbiBpdCBjb21lcyAqYmVmb3JlKiB3aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZWFkLlxuICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zbGljZShzdGFydCAtIHRoaXMuX2J1ZmZlck9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlck9mZnNldCA9IHN0YXJ0O1xuICAgICAgfSAvLyBJZiB0aGUgYnVmZmVyIGlzIGVtcHR5IGFmdGVyIHJlbW92aW5nIG9sZCBkYXRhLCBhbGwgZGF0YSBoYXMgYmVlbiByZWFkLlxuXG5cbiAgICAgIHZhciBoYXNBbGxEYXRhQmVlblJlYWQgPSBsZW4odGhpcy5fYnVmZmVyKSA9PT0gMDtcblxuICAgICAgaWYgKHRoaXMuX2RvbmUgJiYgaGFzQWxsRGF0YUJlZW5SZWFkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBXZSBhbHJlYWR5IHJlbW92ZWQgZGF0YSBiZWZvcmUgYHN0YXJ0YCwgc28gd2UganVzdCByZXR1cm4gdGhlIGZpcnN0XG4gICAgICAvLyBjaHVuayBmcm9tIHRoZSBidWZmZXIuXG5cblxuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5zbGljZSgwLCBlbmQgLSBzdGFydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRlci5jYW5jZWwpIHtcbiAgICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJlYW1Tb3VyY2U7XG59KCk7XG5cbmZ1bmN0aW9uIGxlbihibG9iT3JBcnJheSkge1xuICBpZiAoYmxvYk9yQXJyYXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIGlmIChibG9iT3JBcnJheS5zaXplICE9PSB1bmRlZmluZWQpIHJldHVybiBibG9iT3JBcnJheS5zaXplO1xuICByZXR1cm4gYmxvYk9yQXJyYXkubGVuZ3RoO1xufVxuLypcbiAgVHlwZWQgYXJyYXlzIGFuZCBibG9icyBkb24ndCBoYXZlIGEgY29uY2F0IG1ldGhvZC5cbiAgVGhpcyBmdW5jdGlvbiBoZWxwcyBTdHJlYW1Tb3VyY2UgYWNjdW11bGF0ZSBkYXRhIHRvIHJlYWNoIGNodW5rU2l6ZS5cbiovXG5cblxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgaWYgKGEuY29uY2F0KSB7XG4gICAgLy8gSXMgYGFgIGFuIEFycmF5P1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgQmxvYihbYSwgYl0sIHtcbiAgICAgIHR5cGU6IGEudHlwZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGEuc2V0KSB7XG4gICAgLy8gSXMgYGFgIGEgdHlwZWQgYXJyYXk/XG4gICAgdmFyIGMgPSBuZXcgYS5jb25zdHJ1Y3RvcihhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgICBjLnNldChhKTtcbiAgICBjLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZVwiKTtcbn1cblxudmFyIEZpbGVSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWxlUmVhZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlUmVhZGVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlUmVhZGVyLCBbe1xuICAgIGtleTogXCJvcGVuRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuRmlsZShpbnB1dCwgY2h1bmtTaXplKSB7XG4gICAgICAvLyBJbiBSZWFjdCBOYXRpdmUsIHdoZW4gdXNlciBzZWxlY3RzIGEgZmlsZSwgaW5zdGVhZCBvZiBhIEZpbGUgb3IgQmxvYixcbiAgICAgIC8vIHlvdSB1c3VhbGx5IGdldCBhIGZpbGUgb2JqZWN0IHt9IHdpdGggYSB1cmkgcHJvcGVydHkgdGhhdCBjb250YWluc1xuICAgICAgLy8gYSBsb2NhbCBwYXRoIHRvIHRoZSBmaWxlLiBXZSB1c2UgWE1MSHR0cFJlcXVlc3QgdG8gZmV0Y2hcbiAgICAgIC8vIHRoZSBmaWxlIGJsb2IsIGJlZm9yZSB1cGxvYWRpbmcgd2l0aCB0dXMuXG4gICAgICBpZiAoKDAsIF9pc1JlYWN0TmF0aXZlLmRlZmF1bHQpKCkgJiYgaW5wdXQgJiYgdHlwZW9mIGlucHV0LnVyaSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gKDAsIF91cmlUb0Jsb2IuZGVmYXVsdCkoaW5wdXQudXJpKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaWxlU291cmNlKGJsb2IpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFwiICsgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gICAgICAvLyBzdXBwb3J0IGl0KSwgd2UgY2Fubm90IHVzZSBgaW5zdGFuY2VvZmAgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIC8vIGNhbiBiZSBoYW5kbGVkLiBJbnN0ZWFkLCB3ZSBzaW1wbHkgY2hlY2sgaXMgdGhlIHNsaWNlKCkgZnVuY3Rpb24gYW5kIHRoZVxuICAgICAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2xpY2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgaW5wdXQuc2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBGaWxlU291cmNlKGlucHV0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQucmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9ICtjaHVua1NpemU7XG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZShjaHVua1NpemUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImNhbm5vdCBjcmVhdGUgc291cmNlIGZvciBzdHJlYW0gd2l0aG91dCBhIGZpbml0ZSB2YWx1ZSBmb3IgdGhlIGBjaHVua1NpemVgIG9wdGlvblwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTdHJlYW1Tb3VyY2UoaW5wdXQsIGNodW5rU2l6ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic291cmNlIG9iamVjdCBtYXkgb25seSBiZSBhbiBpbnN0YW5jZSBvZiBGaWxlLCBCbG9iLCBvciBSZWFkZXIgaW4gdGhpcyBlbnZpcm9ubWVudFwiKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVSZWFkZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZpbGVSZWFkZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmaW5nZXJwcmludDtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gVE9ETzogRGlmZmVyZW5jaWF0ZSBiZXR3ZWVuIGlucHV0IHR5cGVzXG5cbi8qKlxuICogR2VuZXJhdGUgYSBmaW5nZXJwcmludCBmb3IgYSBmaWxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0aGUgc3RvcmUgdGhlIGVuZHBvaW50XG4gKlxuICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykge1xuICBpZiAoKDAsIF9pc1JlYWN0TmF0aXZlLmRlZmF1bHQpKCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWN0TmF0aXZlRmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXCJ0dXMtYnJcIiwgZmlsZS5uYW1lLCBmaWxlLnR5cGUsIGZpbGUuc2l6ZSwgZmlsZS5sYXN0TW9kaWZpZWQsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oXCItXCIpKTtcbn1cblxuZnVuY3Rpb24gcmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIHZhciBleGlmSGFzaCA9IGZpbGUuZXhpZiA/IGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KGZpbGUuZXhpZikpIDogXCJub2V4aWZcIjtcbiAgcmV0dXJuIFtcInR1cy1yblwiLCBmaWxlLm5hbWUgfHwgXCJub25hbWVcIiwgZmlsZS5zaXplIHx8IFwibm9zaXplXCIsIGV4aWZIYXNoLCBvcHRpb25zLmVuZHBvaW50XS5qb2luKFwiL1wiKTtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MzE5MzcvMTUxNjY2XG4gIHZhciBoYXNoID0gMDtcblxuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBfY2hhcjtcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgWEhSSHR0cFN0YWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEhSSHR0cFN0YWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYSFJIdHRwU3RhY2spO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhIUkh0dHBTdGFjaywgW3tcbiAgICBrZXk6IFwiY3JlYXRlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICByZXR1cm4gXCJYSFJIdHRwU3RhY2tcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWEhSSHR0cFN0YWNrO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBYSFJIdHRwU3RhY2s7XG5cbnZhciBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXF1ZXN0KTtcblxuICAgIHRoaXMuX3hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgdGhpcy5feGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB0aGlzLl9oZWFkZXJzID0ge307XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVxdWVzdCwgW3tcbiAgICBrZXk6IFwiZ2V0TWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGhvZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXRob2Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVSTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX3hoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuXG4gICAgICB0aGlzLl9oZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlcihoZWFkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFByb2dyZXNzSGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9ncmVzc0hhbmRsZXIocHJvZ3Jlc3NIYW5kbGVyKSB7XG4gICAgICAvLyBUZXN0IHN1cHBvcnQgZm9yIHByb2dyZXNzIGV2ZW50cyBiZWZvcmUgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICBpZiAoIShcInVwbG9hZFwiIGluIHRoaXMuX3hocikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl94aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzSGFuZGxlcihlLmxvYWRlZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl94aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKF90aGlzLl94aHIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX3hoci5zZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVxdWVzdDtcbn0oKTtcblxudmFyIFJlc3BvbnNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzcG9uc2UoeGhyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNlKTtcblxuICAgIHRoaXMuX3hociA9IHhocjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zZSwgW3tcbiAgICBrZXk6IFwiZ2V0U3RhdHVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuc3RhdHVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzcG9uc2U7XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmFibGVEZWJ1Z0xvZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbG9nZ2VyLmVuYWJsZURlYnVnTG9nO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNhblN0b3JlVVJMc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXJsU3RvcmFnZS5jYW5TdG9yZVVSTHM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cFN0YWNrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9odHRwU3RhY2suZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLmlzU3VwcG9ydGVkID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuVXBsb2FkID0gdm9pZCAwO1xuXG52YXIgX3VwbG9hZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3VwbG9hZFwiKSk7XG5cbnZhciBfbm9vcFVybFN0b3JhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ub29wVXJsU3RvcmFnZVwiKSk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcblxudmFyIF91cmxTdG9yYWdlID0gcmVxdWlyZShcIi4vdXJsU3RvcmFnZVwiKTtcblxudmFyIF9odHRwU3RhY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2h0dHBTdGFja1wiKSk7XG5cbnZhciBfZmlsZVJlYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmlsZVJlYWRlclwiKSk7XG5cbnZhciBfZmluZ2VycHJpbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbmdlcnByaW50XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIF91cGxvYWQuZGVmYXVsdC5kZWZhdWx0T3B0aW9ucywge1xuICBodHRwU3RhY2s6IG5ldyBfaHR0cFN0YWNrLmRlZmF1bHQoKSxcbiAgZmlsZVJlYWRlcjogbmV3IF9maWxlUmVhZGVyLmRlZmF1bHQoKSxcbiAgdXJsU3RvcmFnZTogX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzID8gbmV3IF91cmxTdG9yYWdlLldlYlN0b3JhZ2VVcmxTdG9yYWdlKCkgOiBuZXcgX25vb3BVcmxTdG9yYWdlLmRlZmF1bHQoKSxcbiAgZmluZ2VycHJpbnQ6IF9maW5nZXJwcmludC5kZWZhdWx0XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXG52YXIgVXBsb2FkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVVwbG9hZCkge1xuICBfaW5oZXJpdHMoVXBsb2FkLCBfQmFzZVVwbG9hZCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVcGxvYWQpO1xuXG4gIGZ1bmN0aW9uIFVwbG9hZCgpIHtcbiAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBsb2FkKTtcblxuICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucywge30sIG9wdGlvbnMpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmaWxlLCBvcHRpb25zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVcGxvYWQsIG51bGwsIFt7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUodXJsLCBvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCB7fSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gX3VwbG9hZC5kZWZhdWx0LnRlcm1pbmF0ZSh1cmwsIG9wdGlvbnMsIGNiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXBsb2FkO1xufShfdXBsb2FkLmRlZmF1bHQpO1xuXG5leHBvcnRzLlVwbG9hZCA9IFVwbG9hZDtcbnZhciBfd2luZG93ID0gd2luZG93LFxuICAgIFhNTEh0dHBSZXF1ZXN0ID0gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCxcbiAgICBCbG9iID0gX3dpbmRvdy5CbG9iO1xudmFyIGlzU3VwcG9ydGVkID0gWE1MSHR0cFJlcXVlc3QgJiYgQmxvYiAmJiB0eXBlb2YgQmxvYi5wcm90b3R5cGUuc2xpY2UgPT09IFwiZnVuY3Rpb25cIjtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGlzQ29yZG92YSA9IGZ1bmN0aW9uIGlzQ29yZG92YSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiAodHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB3aW5kb3cuQ29yZG92YSAhPSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPSBcInVuZGVmaW5lZFwiKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGlzQ29yZG92YTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNSZWFjdE5hdGl2ZSA9IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSBcInJlYWN0bmF0aXZlXCI7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc1JlYWN0TmF0aXZlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWFkQXNCeXRlQXJyYXk7XG5cbi8qKlxuICogcmVhZEFzQnl0ZUFycmF5IGNvbnZlcnRzIGEgRmlsZSBvYmplY3QgdG8gYSBVaW50OEFycmF5LlxuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgb24gdGhlIEFwYWNoZSBDb3Jkb3ZhIHBsYXRmb3JtLlxuICogU2VlIGh0dHBzOi8vY29yZG92YS5hcGFjaGUub3JnL2RvY3MvZW4vbGF0ZXN0L3JlZmVyZW5jZS9jb3Jkb3ZhLXBsdWdpbi1maWxlL2luZGV4Lmh0bWwjcmVhZC1hLWZpbGVcbiAqL1xuZnVuY3Rpb24gcmVhZEFzQnl0ZUFycmF5KGNodW5rKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCk7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmlUb0Jsb2I7XG5cbi8qKlxuICogdXJpVG9CbG9iIHJlc29sdmVzIGEgVVJJIHRvIGEgQmxvYiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3JcbiAqIFJlYWN0IE5hdGl2ZSB0byByZXRyaWV2ZSBhIGZpbGUgKGlkZW50aWZpZWQgYnkgYSBmaWxlOi8vXG4gKiBVUkkpIGFzIGEgYmxvYi5cbiAqL1xuZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJibG9iXCI7XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJsb2IgPSB4aHIucmVzcG9uc2U7XG4gICAgICByZXNvbHZlKGJsb2IpO1xuICAgIH07XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICB4aHIub3BlbihcIkdFVFwiLCB1cmkpO1xuICAgIHhoci5zZW5kKCk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5XZWJTdG9yYWdlVXJsU3RvcmFnZSA9IGV4cG9ydHMuY2FuU3RvcmVVUkxzID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93LCBsb2NhbFN0b3JhZ2UgKi9cblxuXG52YXIgaGFzU3RvcmFnZSA9IGZhbHNlO1xuXG50cnkge1xuICBoYXNTdG9yYWdlID0gXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3c7IC8vIEF0dGVtcHQgdG8gc3RvcmUgYW5kIHJlYWQgZW50cmllcyBmcm9tIHRoZSBsb2NhbCBzdG9yYWdlIHRvIGRldGVjdCBQcml2YXRlXG4gIC8vIE1vZGUgb24gU2FmYXJpIG9uIGlPUyAoc2VlICM0OSlcblxuICB2YXIga2V5ID0gXCJ0dXNTdXBwb3J0XCI7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG59IGNhdGNoIChlKSB7XG4gIC8vIElmIHdlIHRyeSB0byBhY2Nlc3MgbG9jYWxTdG9yYWdlIGluc2lkZSBhIHNhbmRib3hlZCBpZnJhbWUsIGEgU2VjdXJpdHlFcnJvclxuICAvLyBpcyB0aHJvd24uIFdoZW4gaW4gcHJpdmF0ZSBtb2RlIG9uIGlPUyBTYWZhcmksIGEgUXVvdGFFeGNlZWRlZEVycm9yIGlzXG4gIC8vIHRocm93biAoc2VlICM0OSlcbiAgaWYgKGUuY29kZSA9PT0gZS5TRUNVUklUWV9FUlIgfHwgZS5jb2RlID09PSBlLlFVT1RBX0VYQ0VFREVEX0VSUikge1xuICAgIGhhc1N0b3JhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbnZhciBjYW5TdG9yZVVSTHMgPSBoYXNTdG9yYWdlO1xuZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSBjYW5TdG9yZVVSTHM7XG5cbnZhciBXZWJTdG9yYWdlVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYlN0b3JhZ2VVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJTdG9yYWdlVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViU3RvcmFnZVVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImZpbmRBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBbGxVcGxvYWRzKCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9maW5kRW50cmllcyhcInR1czo6XCIpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2ZpbmRFbnRyaWVzKFwidHVzOjpcIi5jb25jYXQoZmluZ2VycHJpbnQsIFwiOjpcIikpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHVybFN0b3JhZ2VLZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVXBsb2FkKGZpbmdlcnByaW50LCB1cGxvYWQpIHtcbiAgICAgIHZhciBpZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTIpO1xuICAgICAgdmFyIGtleSA9IFwidHVzOjpcIi5jb25jYXQoZmluZ2VycHJpbnQsIFwiOjpcIikuY29uY2F0KGlkKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodXBsb2FkKSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kRW50cmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEVudHJpZXMocHJlZml4KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2tleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgaWYgKF9rZXkuaW5kZXhPZihwcmVmaXgpICE9PSAwKSBjb250aW51ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB1cGxvYWQgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKF9rZXkpKTtcbiAgICAgICAgICB1cGxvYWQudXJsU3RvcmFnZUtleSA9IF9rZXk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHVwbG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBUaGUgSlNPTiBwYXJzZSBlcnJvciBpcyBpbnRlbnRpb25hbGx5IGlnbm9yZWQgaGVyZSwgc28gYSBtYWxmb3JtZWRcbiAgICAgICAgICAvLyBlbnRyeSBpbiB0aGUgc3RvcmFnZSBjYW5ub3QgcHJldmVudCBhbiB1cGxvYWQuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYlN0b3JhZ2VVcmxTdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gV2ViU3RvcmFnZVVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG52YXIgRGV0YWlsZWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhEZXRhaWxlZEVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGV0YWlsZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gRGV0YWlsZWRFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGNhdXNpbmdFcnIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgdmFyIHJlcSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERldGFpbGVkRXJyb3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlcXVlc3QgPSByZXE7XG4gICAgX3RoaXMub3JpZ2luYWxSZXNwb25zZSA9IHJlcztcbiAgICBfdGhpcy5jYXVzaW5nRXJyb3IgPSBjYXVzaW5nRXJyO1xuXG4gICAgaWYgKGNhdXNpbmdFcnIgIT0gbnVsbCkge1xuICAgICAgbWVzc2FnZSArPSBcIiwgY2F1c2VkIGJ5IFwiLmNvbmNhdChjYXVzaW5nRXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmIChyZXEgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlcXVlc3RJZCA9IHJlcS5nZXRIZWFkZXIoXCJYLVJlcXVlc3QtSURcIikgfHwgXCJuL2FcIjtcbiAgICAgIHZhciBtZXRob2QgPSByZXEuZ2V0TWV0aG9kKCk7XG4gICAgICB2YXIgdXJsID0gcmVxLmdldFVSTCgpO1xuICAgICAgdmFyIHN0YXR1cyA9IHJlcyA/IHJlcy5nZXRTdGF0dXMoKSA6IFwibi9hXCI7XG4gICAgICB2YXIgYm9keSA9IHJlcyA/IHJlcy5nZXRCb2R5KCkgfHwgXCJcIiA6IFwibi9hXCI7XG4gICAgICBtZXNzYWdlICs9IFwiLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBcIi5jb25jYXQobWV0aG9kLCBcIiwgdXJsOiBcIikuY29uY2F0KHVybCwgXCIsIHJlc3BvbnNlIGNvZGU6IFwiKS5jb25jYXQoc3RhdHVzLCBcIiwgcmVzcG9uc2UgdGV4dDogXCIpLmNvbmNhdChib2R5LCBcIiwgcmVxdWVzdCBpZDogXCIpLmNvbmNhdChyZXF1ZXN0SWQsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRGV0YWlsZWRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbnZhciBfZGVmYXVsdCA9IERldGFpbGVkRXJyb3I7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZW5hYmxlRGVidWdMb2cgPSBlbmFibGVEZWJ1Z0xvZztcbmV4cG9ydHMubG9nID0gbG9nO1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogXCJvZmZcIiAqL1xudmFyIGlzRW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbmFibGVEZWJ1Z0xvZygpIHtcbiAgaXNFbmFibGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nKG1zZykge1xuICBpZiAoIWlzRW5hYmxlZCkgcmV0dXJuO1xuICBjb25zb2xlLmxvZyhtc2cpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cblxuXG52YXIgTm9vcFVybFN0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb29wVXJsU3RvcmFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9vcFVybFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5vb3BVcmxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJsaXN0QWxsVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0QWxsVXBsb2FkcygpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVwbG9hZCh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9vcFVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE5vb3BVcmxTdG9yYWdlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pzQmFzZSA9IHJlcXVpcmUoXCJqcy1iYXNlNjRcIik7XG5cbnZhciBfdXJsUGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1cmwtcGFyc2VcIikpO1xuXG52YXIgX2Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9lcnJvclwiKSk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuXG52YXIgX3V1aWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V1aWRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBlbmRwb2ludDogbnVsbCxcbiAgdXBsb2FkVXJsOiBudWxsLFxuICBtZXRhZGF0YToge30sXG4gIGZpbmdlcnByaW50OiBudWxsLFxuICB1cGxvYWRTaXplOiBudWxsLFxuICBvblByb2dyZXNzOiBudWxsLFxuICBvbkNodW5rQ29tcGxldGU6IG51bGwsXG4gIG9uU3VjY2VzczogbnVsbCxcbiAgb25FcnJvcjogbnVsbCxcbiAgX29uVXBsb2FkVXJsQXZhaWxhYmxlOiBudWxsLFxuICBvdmVycmlkZVBhdGNoTWV0aG9kOiBmYWxzZSxcbiAgaGVhZGVyczoge30sXG4gIGFkZFJlcXVlc3RJZDogZmFsc2UsXG4gIG9uQmVmb3JlUmVxdWVzdDogbnVsbCxcbiAgb25BZnRlclJlc3BvbnNlOiBudWxsLFxuICBvblNob3VsZFJldHJ5OiBudWxsLFxuICBjaHVua1NpemU6IEluZmluaXR5LFxuICByZXRyeURlbGF5czogWzAsIDEwMDAsIDMwMDAsIDUwMDBdLFxuICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3M6IGZhbHNlLFxuICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogZmFsc2UsXG4gIHVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbjogZmFsc2UsXG4gIHVybFN0b3JhZ2U6IG51bGwsXG4gIGZpbGVSZWFkZXI6IG51bGwsXG4gIGh0dHBTdGFjazogbnVsbFxufTtcblxudmFyIEJhc2VVcGxvYWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlVXBsb2FkKGZpbGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVVwbG9hZCk7IC8vIFdhcm4gYWJvdXQgcmVtb3ZlZCBvcHRpb25zIGZyb20gcHJldmlvdXMgdmVyc2lvbnNcblxuXG4gICAgaWYgKFwicmVzdW1lXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coXCJ0dXM6IFRoZSBgcmVzdW1lYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCBpbiB0dXMtanMtY2xpZW50IHYyLiBQbGVhc2UgdXNlIHRoZSBVUkwgc3RvcmFnZSBBUEkgaW5zdGVhZC5cIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH0gLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB3aWxsIGFscmVhZHkgYmUgYWRkZWQgZnJvbSB0aGUgd3JhcHBlciBjbGFzc2VzLlxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBUaGUgc3RvcmFnZSBtb2R1bGUgdXNlZCB0byBzdG9yZSBVUkxzXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlID0gdGhpcy5vcHRpb25zLnVybFN0b3JhZ2U7IC8vIFRoZSB1bmRlcmx5aW5nIEZpbGUvQmxvYiBvYmplY3RcblxuICAgIHRoaXMuZmlsZSA9IGZpbGU7IC8vIFRoZSBVUkwgYWdhaW5zdCB3aGljaCB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkXG5cbiAgICB0aGlzLnVybCA9IG51bGw7IC8vIFRoZSB1bmRlcmx5aW5nIHJlcXVlc3Qgb2JqZWN0IGZvciB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsOyAvLyBUaGUgZmluZ2VycGlucnQgZm9yIHRoZSBjdXJyZW50IGZpbGUgKHNldCBhZnRlciBzdGFydCgpKVxuXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSBudWxsOyAvLyBUaGUga2V5IHRoYXQgdGhlIFVSTCBzdG9yYWdlIHJldHVybmVkIHdoZW4gc2F2aW5nIGFuIFVSTCB3aXRoIGEgZmluZ2VycHJpbnQsXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gbnVsbDsgLy8gVGhlIG9mZnNldCB1c2VkIGluIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcblxuICAgIHRoaXMuX29mZnNldCA9IG51bGw7IC8vIFRydWUgaWYgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkXG5cbiAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7IC8vIFRoZSBmaWxlJ3Mgc2l6ZSBpbiBieXRlc1xuXG4gICAgdGhpcy5fc2l6ZSA9IG51bGw7IC8vIFRoZSBTb3VyY2Ugb2JqZWN0IHdoaWNoIHdpbGwgd3JhcCBhcm91bmQgdGhlIGdpdmVuIGZpbGUgYW5kIHByb3ZpZGVzIHVzXG4gICAgLy8gd2l0aCBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBnZXR0aW5nIGl0cyBzaXplIGFuZCBzbGljZSBjaHVua3MgZnJvbSBpdHNcbiAgICAvLyBjb250ZW50IGFsbG93aW5nIHVzIHRvIGVhc2lseSBoYW5kbGUgRmlsZXMsIEJsb2JzLCBCdWZmZXJzIGFuZCBTdHJlYW1zLlxuXG4gICAgdGhpcy5fc291cmNlID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgY291bnQgb2YgYXR0ZW1wdHMgd2hpY2ggaGF2ZSBiZWVuIG1hZGUuIFplcm8gaW5kaWNhdGVzIG5vbmUuXG5cbiAgICB0aGlzLl9yZXRyeUF0dGVtcHQgPSAwOyAvLyBUaGUgdGltZW91dCdzIElEIHdoaWNoIGlzIHVzZWQgdG8gZGVsYXkgdGhlIG5leHQgcmV0cnlcblxuICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7IC8vIFRoZSBvZmZzZXQgb2YgdGhlIHJlbW90ZSB1cGxvYWQgYmVmb3JlIHRoZSBsYXRlc3QgYXR0ZW1wdCB3YXMgc3RhcnRlZC5cblxuICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gMDsgLy8gQW4gYXJyYXkgb2YgQmFzZVVwbG9hZCBpbnN0YW5jZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBudWxsOyAvLyBBbiBhcnJheSBvZiB1cGxvYWQgVVJMcyB3aGljaCBhcmUgdXNlZCBmb3IgdXBsb2FkaW5nIHRoZSBkaWZmZXJlbnRcbiAgICAvLyBwYXJ0cywgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZC5cblxuICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVzZSB0aGUgVGVybWluYXRpb24gZXh0ZW5zaW9uIHRvIGRlbGV0ZSBhbiB1cGxvYWQgZnJvbSB0aGUgc2VydmVyIGJ5IHNlbmRpbmcgYSBERUxFVEVcbiAgICogcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIHVwbG9hZCBVUkwuIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIHRoZVxuICAgKiBUZXJtaW5hdGlvbiBleHRlbnNpb24uIElmIHRoZSBgb3B0aW9ucy5yZXRyeURlbGF5c2AgcHJvcGVydHkgaXMgc2V0LCB0aGUgbWV0aG9kIHdpbGxcbiAgICogYWxzbyByZXRyeSBpZiBhbiBlcnJvciBvY3VycnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVwbG9hZCdzIFVSTCB3aGljaCB3aWxsIGJlIHRlcm1pbmF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIGluZmx1ZW5jaW5nIEhUVFAgcmVxdWVzdHMuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVXBsb2FkLCBbe1xuICAgIGtleTogXCJmaW5kUHJldmlvdXNVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRQcmV2aW91c1VwbG9hZHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KHRoaXMuZmlsZSwgdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChmaW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3VybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXN1bWVGcm9tUHJldmlvdXNVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHByZXZpb3VzVXBsb2FkKSB7XG4gICAgICB0aGlzLnVybCA9IHByZXZpb3VzVXBsb2FkLnVwbG9hZFVybCB8fCBudWxsO1xuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gcHJldmlvdXNVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzIHx8IG51bGw7XG4gICAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gcHJldmlvdXNVcGxvYWQudXJsU3RvcmFnZUtleTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGU7XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBubyBmaWxlIG9yIHN0cmVhbSB0byB1cGxvYWQgcHJvdmlkZWRcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5kcG9pbnQgJiYgIXRoaXMub3B0aW9ucy51cGxvYWRVcmwpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogbmVpdGhlciBhbiBlbmRwb2ludCBvciBhbiB1cGxvYWQgVVJMIGlzIHByb3ZpZGVkXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXRyeURlbGF5cyA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cztcblxuICAgICAgaWYgKHJldHJ5RGVsYXlzICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHJ5RGVsYXlzKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzID4gMSkge1xuICAgICAgICAvLyBUZXN0IHdoaWNoIG9wdGlvbnMgYXJlIGluY29tcGF0aWJsZSB3aXRoIHBhcmFsbGVsIHVwbG9hZHMuXG4gICAgICAgIFtcInVwbG9hZFVybFwiLCBcInVwbG9hZFNpemVcIiwgXCJ1cGxvYWRMZW5ndGhEZWZlcnJlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCB1c2UgdGhlIFwiLmNvbmNhdChvcHRpb25OYW1lLCBcIiBvcHRpb24gd2hlbiBwYXJhbGxlbFVwbG9hZHMgaXMgZW5hYmxlZFwiKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucy5maW5nZXJwcmludChmaWxlLCB0aGlzLm9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGZpbmdlcnByaW50KSB7XG4gICAgICAgIGlmIChmaW5nZXJwcmludCA9PSBudWxsKSB7XG4gICAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIk5vIGZpbmdlcnByaW50IHdhcyBjYWxjdWxhdGVkIG1lYW5pbmcgdGhhdCB0aGUgdXBsb2FkIGNhbm5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ2FsY3VsYXRlZCBmaW5nZXJwcmludDogXCIuY29uY2F0KGZpbmdlcnByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfdGhpczIub3B0aW9ucy5maWxlUmVhZGVyLm9wZW5GaWxlKGZpbGUsIF90aGlzMi5vcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfdGhpczIuX3NvdXJjZSA9IHNvdXJjZTsgLy8gSWYgdGhlIHVwbG9hZCB3YXMgY29uZmlndXJlZCB0byB1c2UgbXVsdGlwbGUgcmVxdWVzdHMgb3IgaWYgd2UgcmVzdW1lIGZyb21cbiAgICAgICAgLy8gYW4gdXBsb2FkIHdoaWNoIHVzZWQgbXVsdGlwbGUgcmVxdWVzdHMsIHdlIHN0YXJ0IGEgcGFyYWxsZWwgdXBsb2FkLlxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxIHx8IF90aGlzMi5fcGFyYWxsZWxVcGxvYWRVcmxzICE9IG51bGwpIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0U2luZ2xlVXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIHBhcmFsbGVsaXplZCB1cGxvYWQsIHdoZXJlIG9uZSBmaWxlIGlzIHNwbGl0IGludG9cbiAgICAgKiBtdWx0aXBsZSByZXF1ZXN0IHdoaWNoIGFyZSBydW4gaW4gcGFyYWxsZWwuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFBhcmFsbGVsVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFBhcmFsbGVsVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0b3RhbFNpemUgPSB0aGlzLl9zaXplID0gdGhpcy5fc291cmNlLnNpemU7XG4gICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBbXTtcbiAgICAgIHZhciBwYXJ0Q291bnQgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCA/IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscy5sZW5ndGggOiB0aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzOyAvLyBUaGUgaW5wdXQgZmlsZSB3aWxsIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2xpY2VzIHdoaWNoIGFyZSB1cGxvYWRlZCBpbiBzZXBhcmF0ZVxuICAgICAgLy8gcmVxdWVzdHMuIEhlcmUgd2UgZ2VuZXJhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gZm9yIHRoZSBzbGljZXMuXG5cbiAgICAgIHZhciBwYXJ0cyA9IHNwbGl0U2l6ZUludG9QYXJ0cyh0aGlzLl9zb3VyY2Uuc2l6ZSwgcGFydENvdW50LCB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMpOyAvLyBDcmVhdGUgYW4gZW1wdHkgbGlzdCBmb3Igc3RvcmluZyB0aGUgdXBsb2FkIFVSTHNcblxuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7IC8vIEdlbmVyYXRlIGEgcHJvbWlzZSBmb3IgZWFjaCBzbGljZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZSBpZiB0aGUgcmVzcGVjdGl2ZVxuICAgICAgLy8gdXBsb2FkIGlzIGNvbXBsZXRlZC5cblxuICAgICAgdmFyIHVwbG9hZHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBsYXN0UGFydFByb2dyZXNzID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc291cmNlLnNsaWNlKHBhcnQuc3RhcnQsIHBhcnQuZW5kKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gTWVyZ2Ugd2l0aCB0aGUgdXNlciBzdXBwbGllZCBvcHRpb25zIGJ1dCBvdmVyd3JpdGUgc29tZSB2YWx1ZXMuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zLCB7XG4gICAgICAgICAgICAgIC8vIElmIGF2YWlsYWJsZSwgdGhlIHBhcnRpYWwgdXBsb2FkIHNob3VsZCBiZSByZXN1bWVkIGZyb20gYSBwcmV2aW91cyBVUkwuXG4gICAgICAgICAgICAgIHVwbG9hZFVybDogcGFydC51cGxvYWRVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgLy8gV2UgdGFrZSBtYW51YWxseSBjYXJlIG9mIHJlc3VtaW5nIGZvciBwYXJ0aWFsIHVwbG9hZHMsIHNvIHRoZXkgc2hvdWxkXG4gICAgICAgICAgICAgIC8vIG5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIHRvIG5vdCBjYXVzZSByZWN1cnNpb24uXG4gICAgICAgICAgICAgIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIGhlYWRlciB0byBpbmRpY2F0ZSB0aGUgdGhpcyBpcyBhIHBhcnRpYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKHt9LCBfdGhpczMub3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgXCJVcGxvYWQtQ29uY2F0XCI6IFwicGFydGlhbFwiXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAvLyBSZWplY3Qgb3IgcmVzb2x2ZSB0aGUgcHJvbWlzZSBpZiB0aGUgdXBsb2FkIGVycm9ycyBvciBjb21wbGV0ZXMuXG4gICAgICAgICAgICAgIG9uU3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgb25FcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgICAvLyBCYXNlZCBpbiB0aGUgcHJvZ3Jlc3MgZm9yIHRoaXMgcGFydGlhbCB1cGxvYWQsIGNhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBlbnRpcmUgZmluYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiBvblByb2dyZXNzKG5ld1BhcnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgPSB0b3RhbFByb2dyZXNzIC0gbGFzdFBhcnRQcm9ncmVzcyArIG5ld1BhcnRQcm9ncmVzcztcbiAgICAgICAgICAgICAgICBsYXN0UGFydFByb2dyZXNzID0gbmV3UGFydFByb2dyZXNzO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMzLl9lbWl0UHJvZ3Jlc3ModG90YWxQcm9ncmVzcywgdG90YWxTaXplKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBldmVyeSBwYXJ0aWFsIHVwbG9hZCBoYXMgYW4gdXBsb2FkIFVSTCwgc28gd2UgY2FuIGFkZFxuICAgICAgICAgICAgICAvLyB0aGVtIHRvIHRoZSBVUkwgc3RvcmFnZS5cbiAgICAgICAgICAgICAgX29uVXBsb2FkVXJsQXZhaWxhYmxlOiBmdW5jdGlvbiBfb25VcGxvYWRVcmxBdmFpbGFibGUoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHNbaW5kZXhdID0gdXBsb2FkLnVybDsgLy8gVGVzdCBpZiBhbGwgdXBsb2FkcyBoYXZlIHJlY2VpdmVkIGFuIFVSTFxuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmZpbHRlcihmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLl9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyBCYXNlVXBsb2FkKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpOyAvLyBTdG9yZSB0aGUgdXBsb2FkIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gbGF0ZXIgYWJvcnQgdGhlbSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZXE7IC8vIFdhaXQgdW50aWwgYWxsIHBhcnRpYWwgdXBsb2FkcyBhcmUgZmluaXNoZWQgYW5kIHdlIGNhbiBzZW5kIHRoZSBQT1NUIHJlcXVlc3QgZm9yXG4gICAgICAvLyBjcmVhdGluZyB0aGUgZmluYWwgdXBsb2FkLlxuXG4gICAgICBQcm9taXNlLmFsbCh1cGxvYWRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxID0gX3RoaXMzLl9vcGVuUmVxdWVzdChcIlBPU1RcIiwgX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLUNvbmNhdFwiLCBcImZpbmFsO1wiLmNvbmNhdChfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJscy5qb2luKFwiIFwiKSkpOyAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKF90aGlzMy5vcHRpb25zLm1ldGFkYXRhKTtcblxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IFwiXCIpIHtcbiAgICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLU1ldGFkYXRhXCIsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpczMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzMy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcihcIkxvY2F0aW9uXCIpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlclwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy51cmwgPSByZXNvbHZlVXJsKF90aGlzMy5vcHRpb25zLmVuZHBvaW50LCBsb2NhdGlvbik7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDcmVhdGVkIHVwbG9hZCBhdCBcIi5jb25jYXQoX3RoaXMzLnVybCkpO1xuXG4gICAgICAgIF90aGlzMy5fZW1pdFN1Y2Nlc3MoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczMuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIG5vbi1wYXJhbGxlbCB1cGxvYWQuIEhlcmUgdGhlIGVudGlyZSBmaWxlIGlzXG4gICAgICogdXBsb2FkZWQgaW4gYSBzZXF1ZW50aWFsIG1hdHRlci5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0U2luZ2xlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFNpbmdsZVVwbG9hZCgpIHtcbiAgICAgIC8vIEZpcnN0LCB3ZSBsb29rIGF0IHRoZSB1cGxvYWRMZW5ndGhEZWZlcnJlZCBvcHRpb24uXG4gICAgICAvLyBOZXh0LCB3ZSBjaGVjayBpZiB0aGUgY2FsbGVyIGhhcyBzdXBwbGllZCBhIG1hbnVhbCB1cGxvYWQgc2l6ZS5cbiAgICAgIC8vIEZpbmFsbHksIHdlIHRyeSB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9zaXplID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnVwbG9hZFNpemUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zaXplID0gK3RoaXMub3B0aW9ucy51cGxvYWRTaXplO1xuXG4gICAgICAgIGlmIChpc05hTih0aGlzLl9zaXplKSkge1xuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBjb252ZXJ0IGB1cGxvYWRTaXplYCBvcHRpb24gaW50byBhIG51bWJlclwiKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5fc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGF1dG9tYXRpY2FsbHkgZGVyaXZlIHVwbG9hZCdzIHNpemUgZnJvbSBpbnB1dCBhbmQgbXVzdCBiZSBzcGVjaWZpZWQgbWFudWFsbHkgdXNpbmcgdGhlIGB1cGxvYWRTaXplYCBvcHRpb25cIikpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlc2V0IHRoZSBhYm9ydGVkIGZsYWcgd2hlbiB0aGUgdXBsb2FkIGlzIHN0YXJ0ZWQgb3IgZWxzZSB0aGVcbiAgICAgIC8vIF9wZXJmb3JtVXBsb2FkIHdpbGwgc3RvcCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgaWYgdGhlIHVwbG9hZCBoYXMgYmVlblxuICAgICAgLy8gYWJvcnRlZCBwcmV2aW91c2x5LlxuXG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTsgLy8gVGhlIHVwbG9hZCBoYWQgYmVlbiBzdGFydGVkIHByZXZpb3VzbHkgYW5kIHdlIHNob3VsZCByZXVzZSB0aGlzIFVSTC5cblxuICAgICAgaWYgKHRoaXMudXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByZXZpb3VzIFVSTDogXCIuY29uY2F0KHRoaXMudXJsKSk7XG5cbiAgICAgICAgdGhpcy5fcmVzdW1lVXBsb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBIFVSTCBoYXMgbWFudWFsbHkgYmVlbiBzcGVjaWZpZWQsIHNvIHdlIHRyeSB0byByZXN1bWVcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZFVybCAhPSBudWxsKSB7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJSZXN1bWluZyB1cGxvYWQgZnJvbSBwcm92aWRlZCBVUkw6IFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudXJsKSk7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5vcHRpb25zLnVwbG9hZFVybDtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEFuIHVwbG9hZCBoYXMgbm90IHN0YXJ0ZWQgZm9yIHRoZSBmaWxlIHlldCwgc28gd2Ugc3RhcnQgYSBuZXcgb25lXG5cblxuICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0aW5nIGEgbmV3IHVwbG9hZFwiKTtcblxuICAgICAgdGhpcy5fY3JlYXRlVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGFueSBydW5uaW5nIHJlcXVlc3QgYW5kIHN0b3AgdGhlIGN1cnJlbnQgdXBsb2FkLiBBZnRlciBhYm9ydCBpcyBjYWxsZWQsIG5vIGV2ZW50XG4gICAgICogaGFuZGxlciB3aWxsIGJlIGludm9rZWQgYW55bW9yZS4gWW91IGNhbiB1c2UgdGhlIGBzdGFydGAgbWV0aG9kIHRvIHJlc3VtZSB0aGUgdXBsb2FkXG4gICAgICogYWdhaW4uXG4gICAgICogSWYgYHNob3VsZFRlcm1pbmF0ZWAgaXMgdHJ1ZSwgdGhlIGB0ZXJtaW5hdGVgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSB0aGVcbiAgICAgKiBjdXJyZW50IHVwbG9hZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFRlcm1pbmF0ZSBUcnVlIGlmIHRoZSB1cGxvYWQgc2hvdWxkIGJlIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoc2hvdWxkVGVybWluYXRlLCBjYikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IHRoZSBhYm9ydCBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgYSBjYWxsYmFjayBzaW5jZSB2MiBhbnltb3JlOyBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBQcm9taXNlIGluc3RlYWRcIik7XG4gICAgICB9IC8vIFN0b3AgYW55IHBhcmFsbGVsIHBhcnRpYWwgdXBsb2FkcywgdGhhdCBoYXZlIGJlZW4gc3RhcnRlZCBpbiBfc3RhcnRQYXJhbGxlbFVwbG9hZHMuXG5cblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2FkcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2Fkcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGxvYWQpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoc2hvdWxkVGVybWluYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN0b3AgYW55IGN1cnJlbnQgcnVubmluZyByZXF1ZXN0LlxuXG5cbiAgICAgIGlmICh0aGlzLl9yZXEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlOyAvLyBTdG9wIGFueSB0aW1lb3V0IHVzZWQgZm9yIGluaXRpYXRpbmcgYSByZXRyeS5cblxuICAgICAgaWYgKHRoaXMuX3JldHJ5VGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNob3VsZFRlcm1pbmF0ZSB8fCB0aGlzLnVybCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJhc2VVcGxvYWQudGVybWluYXRlKHRoaXMudXJsLCB0aGlzLm9wdGlvbnMpIC8vIFJlbW92ZSBlbnRyeSBmcm9tIHRoZSBVUkwgc3RvcmFnZSBzaW5jZSB0aGUgdXBsb2FkIFVSTCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRIdHRwRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIG1lc3NhZ2UsIGNhdXNpbmdFcnIpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgX2Vycm9yLmRlZmF1bHQobWVzc2FnZSwgY2F1c2luZ0VyciwgcmVxLCByZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEVycm9yKGVycikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7IC8vIERvIG5vdCBlbWl0IGVycm9ycywgZS5nLiBmcm9tIGFib3J0ZWQgSFRUUCByZXF1ZXN0cywgaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdG9wcGVkLlxuXG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm47IC8vIENoZWNrIGlmIHdlIHNob3VsZCByZXRyeSwgd2hlbiBlbmFibGVkLCBiZWZvcmUgc2VuZGluZyB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV0cnlEZWxheXMgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSB3aWxsIHJlc2V0IHRoZSBhdHRlbXB0IGNvdW50ZXIgaWZcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFscmVhZHkgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXIgKG9mZnNldCAhPSBudWxsKSBhbmRcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFibGUgdG8gdXBsb2FkIGEgc21hbGwgY2h1bmsgb2YgZGF0YSB0byB0aGUgc2VydmVyXG4gICAgICAgIHZhciBzaG91bGRSZXNldERlbGF5cyA9IHRoaXMuX29mZnNldCAhPSBudWxsICYmIHRoaXMuX29mZnNldCA+IHRoaXMuX29mZnNldEJlZm9yZVJldHJ5O1xuXG4gICAgICAgIGlmIChzaG91bGRSZXNldERlbGF5cykge1xuICAgICAgICAgIHRoaXMuX3JldHJ5QXR0ZW1wdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkUmV0cnkoZXJyLCB0aGlzLl9yZXRyeUF0dGVtcHQsIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdGlvbnMucmV0cnlEZWxheXNbdGhpcy5fcmV0cnlBdHRlbXB0KytdO1xuICAgICAgICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1LnN0YXJ0KCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0U3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN1Y2Nlc3MoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQuIFRoaXMgY2F1c2VzXG4gICAgICAgIC8vIG5ldyB1cGxvYWRzIG9mIHRoZSBzYW1lIGZpbGUgdG8gYmUgdHJlYXRlZCBhcyBhIGRpZmZlcmVudCBmaWxlLlxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gd2hlbiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhpc1xuICAgICAqIGRhdGEgbWF5IG5vdCBoYXZlIGJlZW4gYWNjZXB0ZWQgYnkgdGhlIHNlcnZlciB5ZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNTZW50ICBOdW1iZXIgb2YgYnl0ZXMgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1RvdGFsIFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0UHJvZ3Jlc3MoYnl0ZXNTZW50LCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblByb2dyZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MoYnl0ZXNTZW50LCBieXRlc1RvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGEgY2h1bmsgb2YgZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBhbmQgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplICBTaXplIG9mIHRoZSBjaHVuayB0aGF0IHdhcyBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc0FjY2VwdGVkIFRvdGFsIG51bWJlciBvZiBieXRlcyB0aGF0IGhhdmUgYmVlblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1RvdGFsIFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdENodW5rQ29tcGxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRDaHVua0NvbXBsZXRlKGNodW5rU2l6ZSwgYnl0ZXNBY2NlcHRlZCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25DaHVua0NvbXBsZXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbiBleHRlbnNpb24gYnkgc2VuZGluZyBhIFBPU1RcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGlvbiB0aGUgZmlsZSB3aWxsIGJlXG4gICAgICogdXBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IHVuYWJsZSB0byBjcmVhdGUgdXBsb2FkIGJlY2F1c2Ugbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWRcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiUE9TVFwiLCB0aGlzLm9wdGlvbnMuZW5kcG9pbnQpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtRGVmZXItTGVuZ3RoXCIsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1MZW5ndGhcIiwgdGhpcy5fc2l6ZSk7XG4gICAgICB9IC8vIEFkZCBtZXRhZGF0YSBpZiB2YWx1ZXMgaGF2ZSBiZWVuIGFkZGVkXG5cblxuICAgICAgdmFyIG1ldGFkYXRhID0gZW5jb2RlTWV0YWRhdGEodGhpcy5vcHRpb25zLm1ldGFkYXRhKTtcblxuICAgICAgaWYgKG1ldGFkYXRhICE9PSBcIlwiKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTWV0YWRhdGFcIiwgbWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24gJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWRcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuZ2V0SGVhZGVyKFwiTG9jYXRpb25cIik7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2LnVybCA9IHJlc29sdmVVcmwoX3RoaXM2Lm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczYudXJsKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIF90aGlzNi5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNi5fc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vdGhpbmcgdG8gdXBsb2FkIGFuZCBmaWxlIHdhcyBzdWNjZXNzZnVsbHkgY3JlYXRlZFxuICAgICAgICAgIF90aGlzNi5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICAgIF90aGlzNi5fc291cmNlLmNsb3NlKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczYuX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKTtcblxuICAgICAgICBpZiAoX3RoaXM2Lm9wdGlvbnMudXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uKSB7XG4gICAgICAgICAgX3RoaXM2Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM2Ll9vZmZzZXQgPSAwO1xuXG4gICAgICAgICAgX3RoaXM2Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIGNyZWF0ZSB1cGxvYWRcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFRyeSB0byByZXN1bWUgYW4gZXhpc3RpbmcgdXBsb2FkLiBGaXJzdCBhIEhFQUQgcmVxdWVzdCB3aWxsIGJlIHNlbnRcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgb2Zmc2V0LiBJZiB0aGUgcmVxdWVzdCBmYWlscyBhIG5ldyB1cGxvYWQgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQuIEluIHRoZSBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdW1lVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN1bWVVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiSEVBRFwiLCB0aGlzLnVybCk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlcy5nZXRTdGF0dXMoKTtcblxuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCAyMDApKSB7XG4gICAgICAgICAgaWYgKGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGZpbmdlcnByaW50IGFuZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50LFxuICAgICAgICAgICAgLy8gb24gY2xpZW50IGVycm9ycyBzaW5jZSB0aGUgZmlsZSBjYW4gbm90IGJlIGZvdW5kXG4gICAgICAgICAgICBfdGhpczcuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgdXBsb2FkIGlzIGxvY2tlZCAoaW5kaWNhdGVkIGJ5IHRoZSA0MjMgTG9ja2VkIHN0YXR1cyBjb2RlKSwgd2VcbiAgICAgICAgICAvLyBlbWl0IGFuIGVycm9yIGluc3RlYWQgb2YgZGlyZWN0bHkgc3RhcnRpbmcgYSBuZXcgdXBsb2FkLiBUaGlzIHdheSB0aGVcbiAgICAgICAgICAvLyByZXRyeSBsb2dpYyBjYW4gY2F0Y2ggdGhlIGVycm9yIGFuZCB3aWxsIHJldHJ5IHRoZSB1cGxvYWQuIEFuIHVwbG9hZFxuICAgICAgICAgIC8vIGlzIHVzdWFsbHkgbG9ja2VkIGZvciBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIGFuZCB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGFmdGVyd2FyZHMuXG5cblxuICAgICAgICAgIGlmIChzdGF0dXMgPT09IDQyMykge1xuICAgICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyXCIpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfdGhpczcub3B0aW9ucy5lbmRwb2ludCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYXR0ZW1wdCB0byBjcmVhdGUgYSBuZXcgdXBsb2FkIGlmIG5vIGVuZHBvaW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5hYmxlIHRvIHJlc3VtZSB1cGxvYWQgKG5ldyB1cGxvYWQgY2Fubm90IGJlIGNyZWF0ZWQgd2l0aG91dCBhbiBlbmRwb2ludClcIik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgdXBsb2FkXG5cblxuICAgICAgICAgIF90aGlzNy51cmwgPSBudWxsO1xuXG4gICAgICAgICAgX3RoaXM3Ll9jcmVhdGVVcGxvYWQoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIG9mZnNldCB2YWx1ZVwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiKSwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihsZW5ndGgpICYmICFfdGhpczcub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBsZW5ndGggdmFsdWVcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX3RoaXM3Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlKCk7XG4gICAgICAgIH0gLy8gVXBsb2FkIGhhcyBhbHJlYWR5IGJlZW4gY29tcGxldGVkIGFuZCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gZGF0YSB0byB0aGUgc2VydmVyXG5cblxuICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBfdGhpczcuX2VtaXRQcm9ncmVzcyhsZW5ndGgsIGxlbmd0aCk7XG5cbiAgICAgICAgICBfdGhpczcuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczcuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgICBfdGhpczcuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIHJlc3VtZSB1cGxvYWRcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB1cGxvYWRpbmcgdGhlIGZpbGUgdXNpbmcgUEFUQ0ggcmVxdWVzdHMuIFRoZSBmaWxlIHdpbGwgYmUgZGl2aWRlZFxuICAgICAqIGludG8gY2h1bmtzIGFzIHNwZWNpZmllZCBpbiB0aGUgY2h1bmtTaXplIG9wdGlvbi4gRHVyaW5nIHRoZSB1cGxvYWRcbiAgICAgKiB0aGUgb25Qcm9ncmVzcyBldmVudCBoYW5kbGVyIG1heSBiZSBpbnZva2VkIG11bHRpcGxlIHRpbWVzLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzOyAvLyBJZiB0aGUgdXBsb2FkIGhhcyBiZWVuIGFib3J0ZWQsIHdlIHdpbGwgbm90IHNlbmQgdGhlIG5leHQgUEFUQ0ggcmVxdWVzdC5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGlmIHRoZSBhYm9ydCBtZXRob2Qgd2FzIGNhbGxlZCBkdXJpbmcgYSBjYWxsYmFjaywgc3VjaFxuICAgICAgLy8gYXMgb25DaHVua0NvbXBsZXRlIG9yIG9uUHJvZ3Jlc3MuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxOyAvLyBTb21lIGJyb3dzZXIgYW5kIHNlcnZlcnMgbWF5IG5vdCBzdXBwb3J0IHRoZSBQQVRDSCBtZXRob2QuIEZvciB0aG9zZVxuICAgICAgLy8gY2FzZXMsIHlvdSBjYW4gdGVsbCB0dXMtanMtY2xpZW50IHRvIHVzZSBhIFBPU1QgcmVxdWVzdCB3aXRoIHRoZVxuICAgICAgLy8gWC1IVFRQLU1ldGhvZC1PdmVycmlkZSBoZWFkZXIgZm9yIHNpbXVsYXRpbmcgYSBQQVRDSCByZXF1ZXN0LlxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJyaWRlUGF0Y2hNZXRob2QpIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJQT1NUXCIsIHRoaXMudXJsKTtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlgtSFRUUC1NZXRob2QtT3ZlcnJpZGVcIiwgXCJQQVRDSFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiUEFUQ0hcIiwgdGhpcy51cmwpO1xuICAgICAgfVxuXG4gICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiLCB0aGlzLl9vZmZzZXQpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2FkZENodW5rVG9SZXF1ZXN0KHJlcSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHVwbG9hZGluZyBjaHVua1wiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOC5faGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIERvbid0IGVtaXQgYW4gZXJyb3IgaWYgdGhlIHVwbG9hZCB3YXMgYWJvcnRlZCBtYW51YWxseVxuICAgICAgICBpZiAoX3RoaXM4Ll9hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgXCJ0dXM6IGZhaWxlZCB0byB1cGxvYWQgY2h1bmsgYXQgb2Zmc2V0IFwiICsgX3RoaXM4Ll9vZmZzZXQsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2FkZENodW5rdG9SZXF1ZXN0IHJlYWRzIGEgY2h1bmsgZnJvbSB0aGUgc291cmNlIGFuZCBzZW5kcyBpdCB1c2luZyB0aGVcbiAgICAgKiBzdXBwbGllZCByZXF1ZXN0IG9iamVjdC4gSXQgd2lsbCBub3QgaGFuZGxlIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZENodW5rVG9SZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDaHVua1RvUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB2YXIgZW5kID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgICAgIHJlcS5zZXRQcm9ncmVzc0hhbmRsZXIoZnVuY3Rpb24gKGJ5dGVzU2VudCkge1xuICAgICAgICBfdGhpczkuX2VtaXRQcm9ncmVzcyhzdGFydCArIGJ5dGVzU2VudCwgX3RoaXM5Ll9zaXplKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7IC8vIFRoZSBzcGVjaWZpZWQgY2h1bmtTaXplIG1heSBiZSBJbmZpbml0eSBvciB0aGUgY2FsY2x1YXRlZCBlbmQgcG9zaXRpb25cbiAgICAgIC8vIG1heSBleGNlZWQgdGhlIGZpbGUncyBzaXplLiBJbiBib3RoIGNhc2VzLCB3ZSBsaW1pdCB0aGUgZW5kIHBvc2l0aW9uIHRvXG4gICAgICAvLyB0aGUgaW5wdXQncyB0b3RhbCBzaXplIGZvciBzaW1wbGVyIGNhbGN1bGF0aW9ucyBhbmQgY29ycmVjdG5lc3MuXG5cbiAgICAgIGlmICgoZW5kID09PSBJbmZpbml0eSB8fCBlbmQgPiB0aGlzLl9zaXplKSAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIGVuZCA9IHRoaXMuX3NpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICAgICAgICBkb25lID0gX3JlZjIuZG9uZTsgLy8gSWYgdGhlIHVwbG9hZCBsZW5ndGggaXMgZGVmZXJyZWQsIHRoZSB1cGxvYWQgc2l6ZSB3YXMgbm90IHNwZWNpZmllZCBkdXJpbmdcbiAgICAgICAgLy8gdXBsb2FkIGNyZWF0aW9uLiBTbywgaWYgdGhlIGZpbGUgcmVhZGVyIGlzIGRvbmUgcmVhZGluZywgd2Uga25vdyB0aGUgdG90YWxcbiAgICAgICAgLy8gdXBsb2FkIHNpemUgYW5kIGNhbiB0ZWxsIHRoZSB0dXMgc2VydmVyLlxuXG4gICAgICAgIGlmIChfdGhpczkub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCAmJiBkb25lKSB7XG4gICAgICAgICAgX3RoaXM5Ll9zaXplID0gX3RoaXM5Ll9vZmZzZXQgKyAodmFsdWUgJiYgdmFsdWUuc2l6ZSA/IHZhbHVlLnNpemUgOiAwKTtcbiAgICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiLCBfdGhpczkuX3NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczkuX2VtaXRQcm9ncmVzcyhfdGhpczkuX29mZnNldCwgX3RoaXM5Ll9zaXplKTtcblxuICAgICAgICAgIHJldHVybiBfdGhpczkuX3NlbmRSZXF1ZXN0KHJlcSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2hhbmRsZVVwbG9hZFJlc3BvbnNlIGlzIHVzZWQgYnkgcmVxdWVzdHMgdGhhdCBoYXZlbiBiZWVuIHNlbnQgdXNpbmcgX2FkZENodW5rVG9SZXF1ZXN0XG4gICAgICogYW5kIGFscmVhZHkgaGF2ZSByZWNlaXZlZCBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVXBsb2FkUmVzcG9uc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcihcIlVwbG9hZC1PZmZzZXRcIiksIDEwKTtcblxuICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgdGhpcy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBvZmZzZXQgdmFsdWVcIik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0UHJvZ3Jlc3Mob2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fZW1pdENodW5rQ29tcGxldGUob2Zmc2V0IC0gdGhpcy5fb2Zmc2V0LCBvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPT0gdGhpcy5fc2l6ZSkge1xuICAgICAgICAvLyBZYXksIGZpbmFsbHkgZG9uZSA6KVxuICAgICAgICB0aGlzLl9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZS5jbG9zZSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGVyZm9ybVVwbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSFRUUCByZXF1ZXN0IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBtZXRob2QgYW5kIFVSTC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29wZW5SZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcGVuUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgdmFyIHJlcSA9IG9wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5fcmVxID0gcmVxO1xuICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBlbnRyeSBpbiB0aGUgVVJMIHN0b3JhZ2UsIGlmIGl0IGhhcyBiZWVuIHNhdmVkIGJlZm9yZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUZyb21VcmxTdG9yYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl91cmxTdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKHRoaXMuX3VybFN0b3JhZ2VLZXkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczEwLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSB1cGxvYWQgVVJMIHRvIHRoZSBVUkwgc3RvcmFnZSwgaWYgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzOyAvLyBPbmx5IGlmIGEgZmluZ2VycHJpbnQgd2FzIGNhbGN1bGF0ZWQgZm9yIHRoZSBpbnB1dCAoaS5lLiBub3QgYSBzdHJlYW0pLCB3ZSBjYW4gc3RvcmUgdGhlIHVwbG9hZCBVUkwuXG5cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nIHx8ICF0aGlzLl9maW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdG9yZWRVcGxvYWQgPSB7XG4gICAgICAgIHNpemU6IHRoaXMuX3NpemUsXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLm9wdGlvbnMubWV0YWRhdGEsXG4gICAgICAgIGNyZWF0aW9uVGltZTogbmV3IERhdGUoKS50b1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgIC8vIFNhdmUgbXVsdGlwbGUgVVJMcyBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkIC4uLlxuICAgICAgICBzdG9yZWRVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzID0gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gLi4uIG90aGVyd2lzZSB3ZSBqdXN0IHNhdmUgdGhlIG9uZSBhdmFpbGFibGUgVVJMLlxuICAgICAgICBzdG9yZWRVcGxvYWQudXBsb2FkVXJsID0gdGhpcy51cmw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2UuYWRkVXBsb2FkKHRoaXMuX2ZpbmdlcnByaW50LCBzdG9yZWRVcGxvYWQpLnRoZW4oZnVuY3Rpb24gKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTEuX3VybFN0b3JhZ2VLZXkgPSB1cmxTdG9yYWdlS2V5O1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTEuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZW5kUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VuZFJlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHJldHVybiBzZW5kUmVxdWVzdChyZXEsIGJvZHksIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IHRoZSB0ZXJtaW5hdGUgZnVuY3Rpb24gZG9lcyBub3QgYWNjZXB0IGEgY2FsbGJhY2sgc2luY2UgdjIgYW55bW9yZTsgcGxlYXNlIHVzZSB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpbnN0ZWFkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QoXCJERUxFVEVcIiwgdXJsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzZW5kUmVxdWVzdChyZXEsIG51bGwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBBIDIwNCByZXNwb25zZSBpbmRpY2F0ZXMgYSBzdWNjZXNzZnVsbCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXMuZ2V0U3RhdHVzKCkgPT09IDIwNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuZGVmYXVsdChcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB0ZXJtaW5hdGluZyB1cGxvYWRcIiwgbnVsbCwgcmVxLCByZXMpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIF9lcnJvci5kZWZhdWx0KSkge1xuICAgICAgICAgIGVyciA9IG5ldyBfZXJyb3IuZGVmYXVsdChcInR1czogZmFpbGVkIHRvIHRlcm1pbmF0ZSB1cGxvYWRcIiwgZXJyLCByZXEsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnIsIDAsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IC8vIEluc3RlYWQgb2Yga2VlcGluZyB0cmFjayBvZiB0aGUgcmV0cnkgYXR0ZW1wdHMsIHdlIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBkZWxheXNcbiAgICAgICAgLy8gYXJyYXkuIElmIHRoZSBhcnJheSBpcyBlbXB0eSwgYWxsIHJldHJ5IGF0dGVtcHRzIGFyZSB1c2VkIHVwIGFuZCB3ZSB3aWxsIGJ1YmJsZSB1cCB0aGUgZXJyb3IuXG4gICAgICAgIC8vIFdlIHJlY3Vyc2l2ZWx5IGNhbGwgdGhlIHRlcm1pbmF0ZSBmdW5jdGlvbiB3aWxsIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHJldHJ5RGVsYXlzIGFycmF5LlxuXG5cbiAgICAgICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5yZXRyeURlbGF5c1swXTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RlbGF5cyA9IG9wdGlvbnMucmV0cnlEZWxheXMuc2xpY2UoMSk7XG5cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgcmV0cnlEZWxheXM6IHJlbWFpbmluZ0RlbGF5c1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBCYXNlVXBsb2FkLnRlcm1pbmF0ZSh1cmwsIG5ld09wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVXBsb2FkO1xufSgpO1xuXG5mdW5jdGlvbiBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICB2YXIgZW5jb2RlZCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBtZXRhZGF0YSkge1xuICAgIGVuY29kZWQucHVzaChrZXkgKyBcIiBcIiArIF9qc0Jhc2UuQmFzZTY0LmVuY29kZShtZXRhZGF0YVtrZXldKSk7XG4gIH1cblxuICByZXR1cm4gZW5jb2RlZC5qb2luKFwiLFwiKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIG9mIHRoZSBleHBlY3RlZCBjYXRlZ29yeS5cbiAqIEZvciBleGFtcGxlLCBvbmx5IGEgc3RhdHVzIGJldHdlZW4gMjAwIGFuZCAyOTkgd2lsbCBzYXRpc2Z5IHRoZSBjYXRlZ29yeSAyMDAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgY2F0ZWdvcnkpIHtcbiAgcmV0dXJuIHN0YXR1cyA+PSBjYXRlZ29yeSAmJiBzdGF0dXMgPCBjYXRlZ29yeSArIDEwMDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEhUVFAgcmVxdWVzdCB3aXRoIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGFuZCBVUkwuXG4gKiBUaGUgbmVjZXNzYXJ5IGhlYWRlcnMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gZXZlcnkgcmVxdWVzdFxuICogd2lsbCBiZSBhZGRlZCwgaW5jbHVkaW5nIHRoZSByZXF1ZXN0IElELlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIHJlcSA9IG9wdGlvbnMuaHR0cFN0YWNrLmNyZWF0ZVJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICByZXEuc2V0SGVhZGVyKFwiVHVzLVJlc3VtYWJsZVwiLCBcIjEuMC4wXCIpO1xuICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICByZXEuc2V0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWRkUmVxdWVzdElkKSB7XG4gICAgdmFyIHJlcXVlc3RJZCA9ICgwLCBfdXVpZC5kZWZhdWx0KSgpO1xuICAgIHJlcS5zZXRIZWFkZXIoXCJYLVJlcXVlc3QtSURcIiwgcmVxdWVzdElkKTtcbiAgfVxuXG4gIHJldHVybiByZXE7XG59XG4vKipcbiAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkgd2hpbGUgaW52b2tpbmcgdGhlIG9uQmVmb3JlUmVxdWVzdFxuICogYW5kIG9uQWZ0ZXJSZXNwb25zZSBjYWxsYmFja3MuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzZW5kUmVxdWVzdChyZXEsIGJvZHksIG9wdGlvbnMpIHtcbiAgdmFyIG9uQmVmb3JlUmVxdWVzdFByb21pc2UgPSB0eXBlb2Ygb3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIiA/IFByb21pc2UucmVzb2x2ZShvcHRpb25zLm9uQmVmb3JlUmVxdWVzdChyZXEpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICByZXR1cm4gb25CZWZvcmVSZXF1ZXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVxLnNlbmQoYm9keSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgb25BZnRlclJlc3BvbnNlUHJvbWlzZSA9IHR5cGVvZiBvcHRpb25zLm9uQWZ0ZXJSZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiID8gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMub25BZnRlclJlc3BvbnNlKHJlcSwgcmVzKSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHJldHVybiBvbkFmdGVyUmVzcG9uc2VQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYnJvd3NlciBydW5uaW5nIHRoaXMgY29kZSBoYXMgaW50ZXJuZXQgYWNjZXNzLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZSBpbiB0aGUgbm9kZS5qcyBlbnZpcm9ubWVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNPbmxpbmUoKSB7XG4gIHZhciBvbmxpbmUgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwibmF2aWdhdG9yXCIgaW4gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lID09PSBmYWxzZSkge1xuICAgIG9ubGluZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG9ubGluZTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGl0IGlzIG9rIHRvIHJldHJ5IGEgcmVxdWVzdC5cbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSB0aGUgbGFzdCByZXF1ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlBdHRlbXB0IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiByZXRyaWVkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB0dXMgVXBsb2FkIG9wdGlvbnNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVyciwgcmV0cnlBdHRlbXB0LCBvcHRpb25zKSB7XG4gIC8vIFdlIG9ubHkgYXR0ZW1wdCBhIHJldHJ5IGlmXG4gIC8vIC0gcmV0cnlEZWxheXMgb3B0aW9uIGlzIHNldFxuICAvLyAtIHdlIGRpZG4ndCBleGNlZWQgdGhlIG1heGl1bSBudW1iZXIgb2YgcmV0cmllcywgeWV0LCBhbmRcbiAgLy8gLSB0aGlzIGVycm9yIHdhcyBjYXVzZWQgYnkgYSByZXF1ZXN0IG9yIGl0J3MgcmVzcG9uc2UgYW5kXG4gIC8vIC0gdGhlIGVycm9yIGlzIHNlcnZlciBlcnJvciAoaS5lLiBub3QgYSBzdGF0dXMgNHh4IGV4Y2VwdCBhIDQwOSBvciA0MjMpIG9yXG4gIC8vIGEgb25TaG91bGRSZXRyeSBpcyBzcGVjaWZpZWQgYW5kIHJldHVybnMgdHJ1ZVxuICAvLyAtIHRoZSBicm93c2VyIGRvZXMgbm90IGluZGljYXRlIHRoYXQgd2UgYXJlIG9mZmxpbmVcbiAgaWYgKG9wdGlvbnMucmV0cnlEZWxheXMgPT0gbnVsbCB8fCByZXRyeUF0dGVtcHQgPj0gb3B0aW9ucy5yZXRyeURlbGF5cy5sZW5ndGggfHwgZXJyLm9yaWdpbmFsUmVxdWVzdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMub25TaG91bGRSZXRyeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMub25TaG91bGRSZXRyeShlcnIsIHJldHJ5QXR0ZW1wdCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc3RhdHVzID0gZXJyLm9yaWdpbmFsUmVzcG9uc2UgPyBlcnIub3JpZ2luYWxSZXNwb25zZS5nZXRTdGF0dXMoKSA6IDA7XG4gIHJldHVybiAoIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApIHx8IHN0YXR1cyA9PT0gNDA5IHx8IHN0YXR1cyA9PT0gNDIzKSAmJiBpc09ubGluZSgpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgbGluayBnaXZlbiB0aGUgb3JpZ2luIGFzIHNvdXJjZS4gRm9yIGV4YW1wbGUsXG4gKiBpZiBhIEhUVFAgcmVxdWVzdCB0byBodHRwOi8vZXhhbXBsZS5jb20vZmlsZXMvIHJldHVybnMgYSBMb2NhdGlvblxuICogaGVhZGVyIHdpdGggdGhlIHZhbHVlIC91cGxvYWQvYWJjLCB0aGUgcmVzb2x2ZWQgVVJMIHdpbGwgYmU6XG4gKiBodHRwOi8vZXhhbXBsZS5jb20vdXBsb2FkL2FiY1xuICovXG5cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChvcmlnaW4sIGxpbmspIHtcbiAgcmV0dXJuIG5ldyBfdXJsUGFyc2UuZGVmYXVsdChsaW5rLCBvcmlnaW4pLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgZm9yIHRoZSBwYXJ0cyBpZiBhbiB1cGxvYWRcbiAqIGlzIHNwbGl0IGludG8gbXVsdGlwbGUgcGFyYWxsZWwgcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsU2l6ZSBUaGUgYnl0ZSBzaXplIG9mIHRoZSB1cGxvYWQsIHdoaWNoIHdpbGwgYmUgc3BsaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFydENvdW50IFRoZSBudW1iZXIgaW4gaG93IG1hbnkgcGFydHMgdGhlIHVwbG9hZCB3aWxsIGJlIHNwbGl0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJldmlvdXNVcmxzIFRoZSB1cGxvYWQgVVJMcyBmb3IgcHJldmlvdXMgcGFydHMuXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3BsaXRTaXplSW50b1BhcnRzKHRvdGFsU2l6ZSwgcGFydENvdW50LCBwcmV2aW91c1VybHMpIHtcbiAgdmFyIHBhcnRTaXplID0gTWF0aC5mbG9vcih0b3RhbFNpemUgLyBwYXJ0Q291bnQpO1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRDb3VudDsgaSsrKSB7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICBzdGFydDogcGFydFNpemUgKiBpLFxuICAgICAgZW5kOiBwYXJ0U2l6ZSAqIChpICsgMSlcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnRzW3BhcnRDb3VudCAtIDFdLmVuZCA9IHRvdGFsU2l6ZTsgLy8gQXR0YWNoIFVSTHMgZnJvbSBwcmV2aW91cyB1cGxvYWRzLCBpZiBhdmFpbGFibGUuXG5cbiAgaWYgKHByZXZpb3VzVXJscykge1xuICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICBwYXJ0LnVwbG9hZFVybCA9IHByZXZpb3VzVXJsc1tpbmRleF0gfHwgbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuQmFzZVVwbG9hZC5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xudmFyIF9kZWZhdWx0ID0gQmFzZVVwbG9hZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXVpZDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFVVSUQgdjQgYmFzZWQgb24gcmFuZG9tIG51bWJlcnMuIFdlIGludGVudGlvYW5sbHkgdXNlIHRoZSBsZXNzXG4gKiBzZWN1cmUgTWF0aC5yYW5kb20gZnVuY3Rpb24gaGVyZSBzaW5jZSB0aGUgbW9yZSBzZWN1cmUgY3J5cHRvLmdldFJhbmRvbU51bWJlcnNcbiAqIGlzIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtcy5cbiAqIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3IgdXMgc2luY2Ugd2UgdXNlIHRoZSBVVUlEIG9ubHkgZm9yIGdlbmVyYXRpbmcgYVxuICogcmVxdWVzdCBJRCwgc28gd2UgY2FuIGNvcnJlbGF0ZSBzZXJ2ZXIgbG9ncyB0byBjbGllbnQgZXJyb3JzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBmb2xsb3dpbmcgc2l0ZTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9jcmVhdGUtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZSBVVUlEXG4gKi9cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICAgIHYgPSBjID09IFwieFwiID8gciA6IHIgJiAweDMgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSB1dGlscy5tZXJnZSh7XG4gICAgICB1cmw6IGFyZ3VtZW50c1swXVxuICAgIH0sIGFyZ3VtZW50c1sxXSk7XG4gIH1cblxuICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywge21ldGhvZDogJ2dldCd9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBTYWZhcmkgNS03IGxhY2tzIHN1cHBvcnQgZm9yIGNoYW5naW5nIHRoZSBgT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgcHJvcGVydHlcbiAqICAgICBvbiBvYmplY3RzLlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgZnVuY3Rpb24gQmFyICgpIHt9XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICBhcnIuY29uc3RydWN0b3IgPSBCYXJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICBhcnIuY29uc3RydWN0b3IgPT09IEJhciAmJiAvLyBjb25zdHJ1Y3RvciBjYW4gYmUgc2V0XG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59IGVsc2Uge1xuICAvLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuICBCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuICBCdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgc3RyaW5nID0gJycgKyBzdHJpbmdcblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgaXMgZGVwcmVjYXRlZFxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aCB8IDBcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gX2F1Z21lbnQgKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IHNldCBtZXRob2QgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuaW5kZXhPZiA9IEJQLmluZGV4T2ZcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG59ICgpKVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gY2FjaGVkU2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIFRoaXMgZmlsZSBjYW4gYmUgcmVxdWlyZWQgaW4gQnJvd3NlcmlmeSBhbmQgTm9kZS5qcyBmb3IgYXV0b21hdGljIHBvbHlmaWxsXG4vLyBUbyB1c2UgaXQ6ICByZXF1aXJlKCdlczYtcHJvbWlzZS9hdXRvJyk7XG4ndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJykucG9seWZpbGwoKTtcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cblxuXG52YXIgX2lzQXJyYXkgPSB2b2lkIDA7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdm9pZCAwO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdm9pZCAwO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZlcnR4ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKS5yZXF1aXJlKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cblxuICBpZiAoX3N0YXRlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciB0aGVuJCQxID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aGVuJCQxID0gdmFsdWUudGhlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgZXJyb3IgPSB2b2lkIDAsXG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG52YXIgRW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gICAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cbiAgfVxuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiBfZW51bWVyYXRlKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIF9lYWNoRW50cnkoZW50cnksIGkpIHtcbiAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cblxuICAgIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICAgIHZhciBfdGhlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcbiIsIi8qXG4gKiAgYmFzZTY0LmpzXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbiAqICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiAgUmVmZXJlbmNlczpcbiAqICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0XG4gKi9cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgICAgID8gZGVmaW5lKGZhY3RvcnkpIDogZmFjdG9yeShnbG9iYWwpXG59KChcbiAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFxuOiB0aGlzXG4pLCBmdW5jdGlvbihnbG9iYWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gZXhpc3RpbmcgdmVyc2lvbiBmb3Igbm9Db25mbGljdCgpXG4gICAgZ2xvYmFsID0gZ2xvYmFsIHx8IHt9O1xuICAgIHZhciBfQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB2YXIgdmVyc2lvbiA9IFwiMi42LjFcIjtcbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgYjY0Y2hhcnNcbiAgICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgdmFyIGI2NHRhYiA9IGZ1bmN0aW9uKGJpbikge1xuICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJpbi5sZW5ndGg7IGkgPCBsOyBpKyspIHRbYmluLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9KGI2NGNoYXJzKTtcbiAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICAvLyBlbmNvZGVyIHN0dWZmXG4gICAgdmFyIGNiX3V0b2IgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmIChjLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICAgICAgOiBjYyA8IDB4ODAwID8gKGZyb21DaGFyQ29kZSgweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICA6IChmcm9tQ2hhckNvZGUoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNjID0gMHgxMDAwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgwKSAtIDB4RDgwMCkgKiAweDQwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAxMikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlX3V0b2IgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGRl18W15cXHgwMC1cXHg3Rl0vZztcbiAgICB2YXIgdXRvYiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbiAgICB9O1xuICAgIHZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbihjY2MpIHtcbiAgICAgICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM10sXG4gICAgICAgIG9yZCA9IGNjYy5jaGFyQ29kZUF0KDApIDw8IDE2XG4gICAgICAgICAgICB8ICgoY2NjLmxlbmd0aCA+IDEgPyBjY2MuY2hhckNvZGVBdCgxKSA6IDApIDw8IDgpXG4gICAgICAgICAgICB8ICgoY2NjLmxlbmd0aCA+IDIgPyBjY2MuY2hhckNvZGVBdCgyKSA6IDApKSxcbiAgICAgICAgY2hhcnMgPSBbXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoIG9yZCA+Pj4gMTgpLFxuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDEyKSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDEgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQob3JkICYgNjMpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBidG9hID0gZ2xvYmFsLmJ0b2EgJiYgdHlwZW9mIGdsb2JhbC5idG9hID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBmdW5jdGlvbihiKXsgcmV0dXJuIGdsb2JhbC5idG9hKGIpIH0gOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIGlmIChiLm1hdGNoKC9bXlxceDAwLVxceEZGXS8pKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICdUaGUgc3RyaW5nIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBiLnJlcGxhY2UoL1tcXHNcXFNdezEsM30vZywgY2JfZW5jb2RlKTtcbiAgICB9O1xuICAgIHZhciBfZW5jb2RlID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gYnRvYSh1dG9iKFN0cmluZyh1KSkpO1xuICAgIH07XG4gICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uKHUsIHVyaXNhZmUpIHtcbiAgICAgICAgcmV0dXJuICF1cmlzYWZlXG4gICAgICAgICAgICA/IF9lbmNvZGUoU3RyaW5nKHUpKVxuICAgICAgICAgICAgOiBfZW5jb2RlKFN0cmluZyh1KSkucmVwbGFjZSgvWytcXC9dL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0wID09ICcrJyA/ICctJyA6ICdfJztcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLz0vZywgJycpO1xuICAgIH07XG4gICAgdmFyIGVuY29kZVVSSSA9IGZ1bmN0aW9uKHUpIHsgcmV0dXJuIGVuY29kZSh1LCB0cnVlKSB9O1xuICAgIHZhciBmcm9tVWludDhBcnJheSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIGJ0b2EoQXJyYXkuZnJvbShhLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKVxuICAgICAgICB9KS5qb2luKCcnKSk7XG4gICAgfTtcbiAgICAvLyBkZWNvZGVyIHN0dWZmXG4gICAgdmFyIHJlX2J0b3UgPSAvW1xceEMwLVxceERGXVtcXHg4MC1cXHhCRl18W1xceEUwLVxceEVGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYwLVxceEY3XVtcXHg4MC1cXHhCRl17M30vZztcbiAgICB2YXIgY2JfYnRvdSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgc3dpdGNoKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgICAgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCAgNilcbiAgICAgICAgICAgICAgICB8ICAgICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksXG4gICAgICAgICAgICBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgob2Zmc2V0ICA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAgZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnRvdSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTtcbiAgICB9O1xuICAgIHZhciBjYl9kZWNvZGUgPSBmdW5jdGlvbihjY2NjKSB7XG4gICAgICAgIHZhciBsZW4gPSBjY2NjLmxlbmd0aCxcbiAgICAgICAgcGFkbGVuID0gbGVuICUgNCxcbiAgICAgICAgbiA9IChsZW4gPiAwID8gYjY0dGFiW2NjY2MuY2hhckF0KDApXSA8PCAxOCA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAxID8gYjY0dGFiW2NjY2MuY2hhckF0KDEpXSA8PCAxMiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAyID8gYjY0dGFiW2NjY2MuY2hhckF0KDIpXSA8PCAgNiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAzID8gYjY0dGFiW2NjY2MuY2hhckF0KDMpXSAgICAgICA6IDApLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiA+Pj4gMTYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKChuID4+PiAgOCkgJiAweGZmKSxcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiAgICAgICAgICYgMHhmZilcbiAgICAgICAgXTtcbiAgICAgICAgY2hhcnMubGVuZ3RoIC09IFswLCAwLCAyLCAxXVtwYWRsZW5dO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgX2F0b2IgPSBnbG9iYWwuYXRvYiAmJiB0eXBlb2YgZ2xvYmFsLmF0b2IgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGZ1bmN0aW9uKGEpeyByZXR1cm4gZ2xvYmFsLmF0b2IoYSkgfSA6IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gYS5yZXBsYWNlKC9cXFN7MSw0fS9nLCBjYl9kZWNvZGUpO1xuICAgIH07XG4gICAgdmFyIGF0b2IgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBfYXRvYihTdHJpbmcoYSkucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKSk7XG4gICAgfTtcbiAgICB2YXIgX2RlY29kZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGJ0b3UoX2F0b2IoYSkpIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShcbiAgICAgICAgICAgIFN0cmluZyhhKS5yZXBsYWNlKC9bLV9dL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0wID09ICctJyA/ICcrJyA6ICcvJ1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKVxuICAgICAgICApO1xuICAgIH07XG4gICAgdmFyIHRvVWludDhBcnJheSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKGEpLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgcmV0dXJuIEJhc2U2NDtcbiAgICB9O1xuICAgIC8vIGV4cG9ydCBCYXNlNjRcbiAgICBnbG9iYWwuQmFzZTY0ID0ge1xuICAgICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgICBhdG9iOiBhdG9iLFxuICAgICAgICBidG9hOiBidG9hLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIG5vQ29uZmxpY3Q6IG5vQ29uZmxpY3QsXG4gICAgICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICAgICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXlcbiAgICB9O1xuICAgIC8vIGlmIEVTNSBpcyBhdmFpbGFibGUsIG1ha2UgQmFzZTY0LmV4dGVuZFN0cmluZygpIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBub0VudW0gPSBmdW5jdGlvbih2KXtcbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6dixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9O1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWwuQmFzZTY0LmV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAnZnJvbUJhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodGhpcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0Jywgbm9FbnVtKGZ1bmN0aW9uICh1cmlzYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdXJpc2FmZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0VVJJJywgbm9FbnVtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIGlmIChnbG9iYWxbJ01ldGVvciddKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICAvLyBtb2R1bGUuZXhwb3J0cyBhbmQgQU1EIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgaGFzIHByZWNlZGVuY2UuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGdsb2JhbC5CYXNlNjQgfSk7XG4gICAgfVxuICAgIC8vIHRoYXQncyBpdCFcbiAgICByZXR1cm4ge0Jhc2U2NDogZ2xvYmFsLkJhc2U2NH1cbn0pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbCAmJiBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIiwiLy8gVGhlIHJlZ2VuZXJhdG9yIHJ1bnRpbWUgaXMgbmVlZGVkIHNpbmNlIHRoZSB0ZXN0IHVzZSBmdW5jdGlvbnNcbi8vIHdpdGggdGhlIGFzeW5jL2F3YWl0IGtleXdvcmRzLiBTZWVcbi8vIGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL2VuL2JhYmVsLXBsdWdpbi10cmFuc2Zvcm0tcmVnZW5lcmF0b3JcbmltcG9ydCBcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiO1xuLy8gUG9seWZpbGwgYFByb21pc2VgIGZvciBJbnRlcm5ldCBFeHBsb3Jlci5cbmltcG9ydCBcImVzNi1wcm9taXNlL2F1dG9cIjtcblxuLy8gVGhpcyBpcyBhIGZ1biBwaWVjZSBvZiBjb2RlLiBMZXQgbWUgdGVsbCB5b3UgdGhlIHN0b3J5IGJlaGluZCBpdDpcbi8vIEludGVybmV0IEV4cGxvcmVyIDEwIGFuZCAxMSBoYXZlIGEgYnVnIHdoZXJlIHRoZSBldmVudCBoYW5kbGVyc1xuLy8gZm9yIFhNTEh0dHBSZXF1ZXN0cyB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHNpZ25pZmljYW50IGRlbGF5IGFmdGVyXG4vLyB0aGUgYWN0dWFsIHJlcXVlc3QgaGFzIGJlZW4gZmluaXNoZWQuIFNvLCBldmVuIGlmIHRoZSBIVFRQIHJlcXVlc3Rcbi8vIG9ubHkgdG9vayAxcyB0byBjb21wbGV0ZSwgSUUgd2lsbCB3YWl0IGFub3RoZXIgMjBzIGJlZm9yZSBpdCBkZWNpZGVzXG4vLyB0byB0ZWxsIHlvdXIgYXBwbGljYXRpb24gdGhhdCB0aGUgcmVxdWVzdCBoYXMgYmVlbiBmaW5pc2hlZC4gVGhpc1xuLy8gd2FzIG5vdCBhIGJpZyBwcm9ibGVtIGluIGRhaWx5IHVzZSBzaW5jZSB0aGlzIGlzc3VlIGRpZCBvbmx5IG9jY3VyXG4vLyB3aGVuIHRoZSB1c2VyIGRpZCBub3QgaW50ZXJhY3Qgd2l0aCB0aGUgd2VicGFnZSwgZS5nLiBtb3ZlIHRoZSBtb3VzZS5cbi8vIEhvd2V2ZXIsIHdoZW4gdGVzdGluZyBpbiBhdXRvbWF0ZWQgYnJvd3NzZXJzLCBubyB1c2VyIGludGVyYWN0aW9uIHdhc1xuLy8gb2NjdXJyaW5nLlxuLy8gRXZlbnR1YWxseSwgc29tZW9uZSBmaWd1cmVkIG91dCB0aGF0IHRoaXMgd2FzIHJlbGF0ZWQgdG8gYSBQcm9taXNlXG4vLyBwb2x5ZmlsbCB0aGF0IGlzIHVzZWQgYnkgdGhlIGF4aW9zIEhUVFAgY2xpZW50LiBUaGlzIHNvbHV0aW9uIGlzXG4vLyB0byB1c2UgYSB0aW1lb3V0LCBhcyBmb2xsb3dzLCB3aGljaCBpcyBlbm91Z2ggdG8gY2F1c2UgdGhlIG5ldHdvcmtcbi8vIGRlbGF5cyB0byB2YW5pc2guXG4vLyBXaG9ldmVyIGZvdW5kIHRoYXQgcGF0Y2gsIEkgaG9wZSB0aGV5IHdpbGwgZ28gdG8gaGVhdmVuLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvMTg2MlxuZnVuY3Rpb24gdCgpIHtcbiAgd2luZG93LnNldFRpbWVvdXQodCwgMTApO1xufVxudCgpO1xuXG5iZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2xlYXIgbG9jYWxTdG9yYWdlIGJlZm9yZSBldmVyeSB0ZXN0IHRvIHByZXZlbnQgc3RvcmVkIFVSTHMgdG9cbiAgLy8gaW50ZXJmZXJlIHdpdGggb3VyIHNldHVwLlxuICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbn0pO1xuXG5yZXF1aXJlKFwiLi9oZWxwZXJzL3B1cHBldGVlci9yZXBvcnRlci5qc1wiKTtcbnJlcXVpcmUoXCIuL3Rlc3QtY29tbW9uLmpzXCIpO1xucmVxdWlyZShcIi4vdGVzdC1icm93c2VyLXNwZWNpZmljLmpzXCIpO1xucmVxdWlyZShcIi4vdGVzdC1wYXJhbGxlbC11cGxvYWRzLmpzXCIpO1xucmVxdWlyZShcIi4vdGVzdC10ZXJtaW5hdGUuanNcIik7XG5yZXF1aXJlKFwiLi90ZXN0LWVuZC10by1lbmQuanNcIik7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIGFzc2VydFVybFN0b3JhZ2UodXJsU3RvcmFnZSkge1xuICAvLyBJbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXN0LCB0aGUgc3RvcmFnZSBzaG91bGQgYmUgZW1wdHkuXG4gIGxldCByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRBbGxVcGxvYWRzKCk7XG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuXG4gIC8vIEFkZCBhIGZldyB1cGxvYWRzIGludG8gdGhlIHN0b3JhZ2VcbiAgY29uc3Qga2V5MSA9IGF3YWl0IHVybFN0b3JhZ2UuYWRkVXBsb2FkKFwiZmluZ2VycHJpbnRBXCIsIHsgaWQ6IDEgfSk7XG4gIGNvbnN0IGtleTIgPSBhd2FpdCB1cmxTdG9yYWdlLmFkZFVwbG9hZChcImZpbmdlcnByaW50QVwiLCB7IGlkOiAyIH0pO1xuICBjb25zdCBrZXkzID0gYXdhaXQgdXJsU3RvcmFnZS5hZGRVcGxvYWQoXCJmaW5nZXJwcmludEJcIiwgeyBpZDogMyB9KTtcblxuICBleHBlY3QoL150dXM6OmZpbmdlcnByaW50QTo6Ly50ZXN0KGtleTEpKS50b0JlKHRydWUpO1xuICBleHBlY3QoL150dXM6OmZpbmdlcnByaW50QTo6Ly50ZXN0KGtleTIpKS50b0JlKHRydWUpO1xuICBleHBlY3QoL150dXM6OmZpbmdlcnByaW50Qjo6Ly50ZXN0KGtleTMpKS50b0JlKHRydWUpO1xuXG4gIC8vIFF1ZXJ5IHRoZSBqdXN0IHN0b3JlZCB1cGxvYWRzIGluZGl2aWR1YWxseVxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChcImZpbmdlcnByaW50QVwiKTtcbiAgc29ydChyZXN1bHQpO1xuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gICAgeyBpZDogMiwgdXJsU3RvcmFnZUtleToga2V5MiB9XG4gIF0pO1xuXG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KFwiZmluZ2VycHJpbnRCXCIpO1xuICBzb3J0KHJlc3VsdCk7XG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1xuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfVxuICBdKTtcblxuICAvLyBDaGVjayB0aGF0IHdlIGNhbiByZXRyaWV2ZSBhbGwgc3RvcmVkIHVwbG9hZHNcbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpO1xuICBzb3J0KHJlc3VsdCk7XG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1xuICAgIHsgaWQ6IDEsIHVybFN0b3JhZ2VLZXk6IGtleTEgfSxcbiAgICB7IGlkOiAyLCB1cmxTdG9yYWdlS2V5OiBrZXkyIH0sXG4gICAgeyBpZDogMywgdXJsU3RvcmFnZUtleToga2V5MyB9XG4gIF0pO1xuXG4gIC8vIENoZWNrIHRoYXQgaXQgY2FuIHJlbW92ZSBhbiB1cGxvYWQgYW5kIHdpbGwgbm90IHJldHVybiBpdCBiYWNrXG4gIGF3YWl0IHVybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKGtleTIpO1xuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkzKTtcblxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChcImZpbmdlcnByaW50QVwiKTtcbiAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXG4gICAgeyBpZDogMSwgdXJsU3RvcmFnZUtleToga2V5MSB9XG4gIF0pO1xuXG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KFwiZmluZ2VycHJpbnRCXCIpO1xuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbn07XG5cbi8vIFNvcnQgdGhlIHJlc3VsdHMgZnJvbSB0aGUgVVJMIHN0b3JhZ2Ugc2luY2UgdGhlIG9yZGVyIGluIG5vdCBkZXRlcm1pbmlzdGljLlxuZnVuY3Rpb24gc29ydChyZXN1bHQpIHtcbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcbn1cbiIsIi8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IDAgKi9cblxudmFyIHRlc3RzQ29tcGxldGVkID0gZmFsc2U7XG52YXIgdGVzdHNQYXNzZWQgPSB0cnVlO1xuXG4vLyBUaGlzIHJlcG9ydGVyIGlzIHVzZWQgYnkgYmluL3B1cHBldGVlci1qYXNtaW5lLmpzIHRvIG9idGFpbiB0aGUgdGVzdCByZXN1bHRzLlxuLy8gU2VlIGh0dHBzOi8vamFzbWluZS5naXRodWIuaW8vYXBpL2VkZ2UvUmVwb3J0ZXIuaHRtbCBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoZVxuLy8gZnVuY3Rpb24gc2lnbmF0dXJlcy5cbnZhciByZXBvcnRlciA9IHtcbiAgamFzbWluZVN0YXJ0ZWQ6IGZ1bmN0aW9uIChzdWl0ZUluZm8pIHsgfSxcbiAgc3VpdGVTdGFydGVkOiBmdW5jdGlvbiAocmVzdWx0KSB7IH0sXG4gIHNwZWNTdGFydGVkOiBmdW5jdGlvbiAocmVzdWx0KSB7IH0sXG4gIHNwZWNEb25lOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgLy8gUHJpbnQgdGhlIHRlc3QgcmVzdWx0IHRvIHRoZSBjb25zb2xlLlxuICAgIHZhciBwYXNzZWQgPSByZXN1bHQuc3RhdHVzID09PSBcInBhc3NlZFwiO1xuICAgIHZhciBwcmVmaXggPSBwYXNzZWQgPyBcIuKck1wiIDogXCLinJhcIjtcbiAgICBjb25zb2xlLmxvZyhwcmVmaXgsIHJlc3VsdC5mdWxsTmFtZSk7XG5cbiAgICB0ZXN0c0NvbXBsZXRlZCA9IHRydWU7XG4gICAgdGVzdHNQYXNzZWQgPSB0ZXN0c1Bhc3NlZCAmJiBwYXNzZWQ7XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsdXJlOiBcIiArIHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnNbaV0ubWVzc2FnZSk7XG4gICAgICBjb25zb2xlLmxvZyhyZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zW2ldLnN0YWNrKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIH1cblxuICB9LFxuICBzdWl0ZURvbmU6IGZ1bmN0aW9uIChyZXN1bHQpIHsgfSxcbiAgamFzbWluZURvbmU6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIgc3VjY2VzcyA9IHRlc3RzQ29tcGxldGVkICYmIHRlc3RzUGFzc2VkO1xuXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVGVzdHMgcGFzc2VkIVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJUZXN0cyBmYWlsZWQhXCIpO1xuICAgIH1cblxuICAgIC8vIFRoZSBfX2phc21pbmVDYWxsYmFjayBmdW5jdGlvbiBpcyBleHBvc2VkIGJ5IHRoZSBiaW4vcHVwcGV0ZWVyLWphc21pbmUuanNcbiAgICAvLyBzY3JpcHQuIFNlZSBpdCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGlmICh0eXBlb2Ygd2luZG93Ll9famFzbWluZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdpbmRvdy5fX2phc21pbmVDYWxsYmFjayhzdWNjZXNzKTtcbiAgICB9XG4gIH1cbn07XG5cbndpbmRvdy5qYXNtaW5lLmdldEVudigpLmFkZFJlcG9ydGVyKHJlcG9ydGVyKTtcbiIsImNvbnN0IGlzQnJvd3NlciAgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgaXNOb2RlICAgICA9ICFpc0Jyb3dzZXI7XG5cbi8qKlxuICogT2J0YWluIGEgcGxhdGZvcm0gc3BlY2lmaWMgYnVmZmVyIG9iamVjdCwgd2hpY2ggY2FuIGJlXG4gKiBoYW5kbGVkIGJ5IHR1cy1qcy1jbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2Ioc3RyKSB7XG4gIGlmIChpc05vZGUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJsb2Ioc3RyLnNwbGl0KFwiXCIpKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHByb21pc2UgYW5kIG9idGFpbiB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zXG4gKiBvdXRzaWRlIG9mIHRoZSBQcm9taXNlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmbGF0UHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmVGbjtcbiAgbGV0IHJlamVjdEZuO1xuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc29sdmVGbiA9IHJlc29sdmU7XG4gICAgcmVqZWN0Rm4gPSByZWplY3Q7XG4gIH0pO1xuXG4gIHJldHVybiBbIHAsIHJlc29sdmVGbiwgcmVqZWN0Rm4gXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzcHktYWJsZSBmdW5jdGlvbiB3aGljaCByZXNvbHZlcyBhIFByb21pc2VcbiAqIG9uY2UgaXQgaXMgY2FsbGVkLlxuICovXG5mdW5jdGlvbiB3YWl0YWJsZUZ1bmN0aW9uKG5hbWUgPSBcImZ1bmNcIikge1xuICBjb25zdCBbIHByb21pc2UsIHJlc29sdmUgXSA9IGZsYXRQcm9taXNlKCk7XG4gIGNvbnN0IGZuID0gamFzbWluZS5jcmVhdGVTcHkobmFtZSwgcmVzb2x2ZSkuYW5kLmNhbGxUaHJvdWdoKCk7XG5cbiAgZm4udG9CZUNhbGxlZCA9IHByb21pc2U7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXksIFwidGltZWQgb3V0XCIpKTtcbn1cblxuLyoqXG4gKiBUZXN0SHR0cFN0YWNrIGltcGxlbWVudHMgdGhlIEhUVFAgc3RhY2sgaW50ZXJmYWNlIGZvciB0dXMtanMtY2xpZW50XG4gKiBhbmQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IG91dGdvaW5nIHJlcXVlc3RzIGFuZCByZXNwb25kIHdpdGggbW9jayBkYXRhLlxuICovXG5jbGFzcyBUZXN0SHR0cFN0YWNrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fcGVuZGluZ1dhaXRzID0gW107XG4gIH1cblxuICBjcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBUZXN0UmVxdWVzdChtZXRob2QsIHVybCwgKHJlcSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdXYWl0cy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcGVuZGluZ1dhaXRzLnNoaWZ0KCk7XG4gICAgICAgIGhhbmRsZXIocmVxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMucHVzaChyZXEpO1xuICAgIH0pO1xuICB9XG5cbiAgbmV4dFJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5sZW5ndGggPj0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9wZW5kaW5nUmVxdWVzdHMuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9wZW5kaW5nV2FpdHMucHVzaChyZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBUZXN0UmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKG1ldGhvZCwgdXJsLCBvblJlcXVlc3RTZW5kKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHt9O1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG5cbiAgICB0aGlzLl9vblJlcXVlc3RTZW5kID0gb25SZXF1ZXN0U2VuZDtcbiAgICB0aGlzLl9vblByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBbIHRoaXMuX3JlcXVlc3RQcm9taXNlLCB0aGlzLl9yZXNvbHZlUmVxdWVzdCwgdGhpcy5fcmVqZWN0UmVxdWVzdCBdID0gZmxhdFByb21pc2UoKTtcbiAgfVxuXG4gIGdldE1ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2Q7XG4gIH1cblxuICBnZXRVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsO1xuICB9XG5cbiAgc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpIHtcbiAgICB0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgfVxuXG4gIGdldEhlYWRlcihoZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SGVhZGVyc1toZWFkZXJdIHx8IG51bGw7XG4gIH1cblxuICBzZXRQcm9ncmVzc0hhbmRsZXIocHJvZ3Jlc3NIYW5kbGVyKSB7XG4gICAgdGhpcy5fb25Qcm9ncmVzcyA9IHByb2dyZXNzSGFuZGxlcjtcbiAgfVxuXG4gIHNlbmQoYm9keSA9IG51bGwpIHtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3MoMCk7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKGJvZHkubGVuZ3RoIHx8IGJvZHkuc2l6ZSB8fCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vblJlcXVlc3RTZW5kKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0UHJvbWlzZTtcbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHRoaXMuX3JlamVjdFJlcXVlc3QobmV3IEVycm9yKFwicmVxdWVzdCBhYm9ydGVkXCIpKTtcbiAgfVxuXG4gIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgcmVzcG9uZFdpdGgocmVzRGF0YSkge1xuICAgIHJlc0RhdGEucmVzcG9uc2VIZWFkZXJzID0gcmVzRGF0YS5yZXNwb25zZUhlYWRlcnMgfHwge307XG5cbiAgICBjb25zdCByZXMgPSBuZXcgVGVzdFJlc3BvbnNlKHJlc0RhdGEpO1xuICAgIHRoaXMuX3Jlc29sdmVSZXF1ZXN0KHJlcyk7XG4gIH1cblxuICByZXNwb25zZUVycm9yKGVycikge1xuICAgIHRoaXMuX3JlamVjdFJlcXVlc3QoZXJyKTtcbiAgfVxufVxuXG5jbGFzcyBUZXN0UmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICB0aGlzLl9yZXNwb25zZSA9IHJlcztcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnN0YXR1cztcbiAgfVxuXG5cbiAgZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5yZXNwb25zZUhlYWRlcnNbaGVhZGVyXTtcbiAgfVxuXG4gIGdldEJvZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnJlc3BvbnNlVGV4dDtcbiAgfVxuXG4gIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUZXN0SHR0cFN0YWNrLFxuICB3YWl0YWJsZUZ1bmN0aW9uLFxuICB3YWl0LFxuICBnZXRCbG9iXG59O1xuIiwiLyogZ2xvYmFsIEJsb2IgICovXG5cbmNvbnN0IGFzc2VydFVybFN0b3JhZ2UgPSByZXF1aXJlKFwiLi9oZWxwZXJzL2Fzc2VydFVybFN0b3JhZ2VcIik7XG5jb25zdCB7IFRlc3RIdHRwU3RhY2ssIHdhaXRhYmxlRnVuY3Rpb24sIHdhaXQgfSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbHNcIik7XG5jb25zdCB0dXMgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuXG5kZXNjcmliZShcInR1c1wiLCBmdW5jdGlvbiAoKSB7XG4gIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICB9KTtcblxuICBkZXNjcmliZShcIiNVcGxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGl0KFwic2hvdWxkIHJlc3VtZSBhbiB1cGxvYWQgZnJvbSBhIHN0b3JlZCB1cmxcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzdcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCJcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gbmV3IEJsb2IoXCJoZWxsbyB3b3JsZFwiLnNwbGl0KFwiXCIpKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmaW5nZXJwcmludDogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcImZpbmdlcnByaW50XCIpLmFuZC5yZXNvbHZlVG8oXCJmaW5nZXJwcmludGVkXCIpO1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvblByb2dyZXNzXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG5cbiAgICAgIGNvbnN0IHByZXZpb3VzVXBsb2FkcyA9IGF3YWl0IHVwbG9hZC5maW5kUHJldmlvdXNVcGxvYWRzKCk7XG4gICAgICBleHBlY3QocHJldmlvdXNVcGxvYWRzKS50b0VxdWFsKFt7XG4gICAgICAgIHVwbG9hZFVybDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIixcbiAgICAgICAgdXJsU3RvcmFnZUtleTogXCJ0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzdcIlxuICAgICAgfV0pO1xuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZHNbMF0pO1xuXG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGZpbGUsIHVwbG9hZC5vcHRpb25zKTtcblxuICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExLFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEgLSAzKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJzdG9yaW5nIG9mIHVwbG9hZCB1cmxzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBmaW5nZXJwcmludDogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG5cbiAgICAgIHZhciBzdGFydFVwbG9hZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBuZXcgQmxvYihcImhlbGxvIHdvcmxkXCIuc3BsaXQoXCJcIikpO1xuICAgICAgICBzcHlPbihvcHRpb25zLCBcImZpbmdlcnByaW50XCIpLmFuZC5yZXNvbHZlVG8oXCJmaW5nZXJwcmludGVkXCIpO1xuICAgICAgICBvcHRpb25zLm9uU3VjY2VzcyA9IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIik7XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiL3VwbG9hZHMvYmxhcmdoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdhaXQgYSBzaG9ydCBkZWxheSB0byBhbGxvdyB0aGUgUHJvbWlzZXMgdG8gc2V0dGxlXG4gICAgICAgIGF3YWl0IHdhaXQoMTApO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZpbmlzaFVwbG9hZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgIH07XG5cbiAgICAgIGl0KFwic2hvdWxkIHN0b3JlIGFuZCByZXRhaW4gd2l0aCBkZWZhdWx0IG9wdGlvbnNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBvcHRpb25zLnJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHN0YXJ0VXBsb2FkKCk7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleSgwKTtcbiAgICAgICAgZXhwZWN0KGtleS5pbmRleE9mKFwidHVzOjpmaW5nZXJwcmludGVkOjpcIikpLnRvQmUoMCk7XG5cbiAgICAgICAgY29uc3Qgc3RvcmVkVXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC51cGxvYWRVcmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnNpemUpLnRvQmUoMTEpO1xuXG4gICAgICAgIGF3YWl0IGZpbmlzaFVwbG9hZCgpO1xuXG4gICAgICAgIGV4cGVjdChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKS50b0JlKEpTT04uc3RyaW5naWZ5KHN0b3JlZFVwbG9hZCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwic2hvdWxkIHN0b3JlIGFuZCByZW1vdmUgd2l0aCBvcHRpb24gcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3Mgc2V0XCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGF3YWl0IHN0YXJ0VXBsb2FkKCk7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleSgwKTtcbiAgICAgICAgZXhwZWN0KGtleS5pbmRleE9mKFwidHVzOjpmaW5nZXJwcmludGVkOjpcIikpLnRvQmUoMCk7XG5cbiAgICAgICAgY29uc3Qgc3RvcmVkVXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC51cGxvYWRVcmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnNpemUpLnRvQmUoMTEpO1xuXG4gICAgICAgIGF3YWl0IGZpbmlzaFVwbG9hZCgpO1xuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShudWxsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZGVsZXRlIHVwbG9hZCB1cmxzIG9uIGEgNFhYXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IG5ldyBCbG9iKFwiaGVsbG8gd29ybGRcIi5zcGxpdChcIlwiKSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBmaW5nZXJwcmludDogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcImZpbmdlcnByaW50XCIpLmFuZC5yZXNvbHZlVG8oXCJmaW5nZXJwcmludGVkXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG5cbiAgICAgIHVwbG9hZC5yZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQoe1xuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIsXG4gICAgICAgIHVybFN0b3JhZ2VLZXk6IFwidHVzOjpmaW5nZXJwcmludGVkOjoxMzM3XCJcbiAgICAgIH0pO1xuXG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDAwXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdCgxMCk7XG5cbiAgICAgIGV4cGVjdChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInR1czo6ZmluZ2VycHJpbnRlZDo6MTMzN1wiKSkudG9CZShudWxsKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwidXBsb2FkaW5nIGRhdGEgZnJvbSBhIFJlYWRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBtYWtlUmVhZGVyKGNvbnRlbnQsIHJlYWRTaXplID0gY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0ge1xuICAgICAgICAgIHZhbHVlOiBjb250ZW50LnNwbGl0KFwiXCIpLFxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UoMCxyZWFkU2l6ZSk7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnNsaWNlKHJlYWRTaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZG9uZSB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbDogd2FpdGFibGVGdW5jdGlvbihcImNhbmNlbFwiKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGFzc2VydFJlYWRlclVwbG9hZCh7IHJlYWRTaXplLCBjaHVua1NpemUgfSkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcihcImhlbGxvIHdvcmxkXCIsIHJlYWRTaXplKTtcblxuICAgICAgICB2YXIgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgICAgY2h1bmtTaXplOiBjaHVua1NpemUsXG4gICAgICAgICAgb25Qcm9ncmVzczogd2FpdGFibGVGdW5jdGlvbihcIm9uUHJvZ3Jlc3NcIiksXG4gICAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpLFxuICAgICAgICAgIGZpbmdlcnByaW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBzcHlPbihvcHRpb25zLCBcImZpbmdlcnByaW50XCIpLmFuZC5yZXNvbHZlVG8oXCJmaW5nZXJwcmludGVkXCIpO1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocmVhZGVyLCB1cGxvYWQub3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSh1bmRlZmluZWQpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLURlZmVyLUxlbmd0aFwiXSkudG9CZSgxKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5sZW5ndGgpLnRvQmUoMTEpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25Qcm9ncmVzcy50b0JlQ2FsbGVkO1xuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgbnVsbCk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMTEpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxMSk7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgICBleHBlY3QocmVxLmJvZHkpLnRvQmUobnVsbCk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgICAgfVxuXG4gICAgICBpdChcInNob3VsZCB1cGxvYWQgZGF0YVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF3YWl0IGFzc2VydFJlYWRlclVwbG9hZCh7IGNodW5rU2l6ZTogMTAwLCByZWFkU2l6ZTogMTAwIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwic2hvdWxkIHJlYWQgbXVsdGlwbGUgdGltZXMgZnJvbSB0aGUgcmVhZGVyXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXdhaXQgYXNzZXJ0UmVhZGVyVXBsb2FkKHsgY2h1bmtTaXplOiAxMDAsIHJlYWRTaXplOiA2IH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwic2hvdWxkIHVzZSBtdWx0aXBsZSBQQVRDSCByZXF1ZXN0c1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBtYWtlUmVhZGVyKFwiaGVsbG8gd29ybGRcIiwgMSk7XG5cbiAgICAgICAgdmFyIHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICAgIGNodW5rU2l6ZTogNixcbiAgICAgICAgICBvblByb2dyZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25Qcm9ncmVzc1wiKSxcbiAgICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIiksXG4gICAgICAgICAgZmluZ2VycHJpbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHNweU9uKG9wdGlvbnMsIFwiZmluZ2VycHJpbnRcIikuYW5kLnJlc29sdmVUbyhcImZpbmdlcnByaW50ZWRcIik7XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChyZWFkZXIsIHVwbG9hZC5vcHRpb25zKTtcblxuICAgICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKHVuZGVmaW5lZCk7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtRGVmZXItTGVuZ3RoXCJdKS50b0JlKDEpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5Lmxlbmd0aCkudG9CZSg2KTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDZcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25Qcm9ncmVzcy50b0JlQ2FsbGVkO1xuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg2LCBudWxsKTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSg2KTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5sZW5ndGgpLnRvQmUoNSk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMTEpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxMSk7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgICBleHBlY3QocmVxLmJvZHkpLnRvQmUobnVsbCk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwic2hvdWxkIHJldHJ5IHRoZSBQT1NUIHJlcXVlc3RcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcihcImhlbGxvIHdvcmxkXCIsIDEpO1xuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICAgIGNodW5rU2l6ZTogMTEsXG4gICAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIiksXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogXCIvZmlsZXMvZm9vXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxMSk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCByZXRyeSB0aGUgZmlyc3QgUEFUQ0ggcmVxdWVzdFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBtYWtlUmVhZGVyKFwiaGVsbG8gd29ybGRcIiwgMSk7XG5cbiAgICAgICAgdmFyIHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgICAgY2h1bmtTaXplOiAxMSxcbiAgICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogNTAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJzaG91bGQgcmV0cnkgZm9sbG93aW5nIFBBVENIIHJlcXVlc3RzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG1ha2VSZWFkZXIoXCJoZWxsbyB3b3JsZCB0aGVyZSFcIik7XG5cbiAgICAgICAgdmFyIHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgICAgY2h1bmtTaXplOiA2LFxuICAgICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDZcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDZcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMThcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxOCk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxOFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCBjYW5jZWwgdGhlIHJlYWRlciB3aGVuIGFib3J0ZWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcihcImhlbGxvIHRoZXJlIHdvcmxkXCIpO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogbmV3IFRlc3RIdHRwU3RhY2soKSxcbiAgICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICAgIGNodW5rU2l6ZTogNixcbiAgICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgLy8gV2Ugd2FpdCB1bnRpbCB0aGUgZmlyc3QgcmVxdWVzdCBhcnJpdmVzLCBzbyB0aGF0IHRoZSBmaXJzdCBwcm9taXNlcyBoYXZlIHJlc29sdmVkLlxuICAgICAgICBhd2FpdCBvcHRpb25zLmh0dHBTdGFjay5uZXh0UmVxdWVzdCgpO1xuXG4gICAgICAgIHVwbG9hZC5hYm9ydCgpO1xuXG4gICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwudG9CZUNhbGxlZDtcbiAgICAgICAgZXhwZWN0KHJlYWRlci5jYW5jZWwpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJyZXNvbHZpbmcgb2YgVVJJc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEaXNhYmxlIHRoZXNlIHRlc3RzIGZvciBJRSAxMCBhbmQgMTEgYmVjYXVzZSBpdCdzIG5vdCBwb3NzaWJsZSB0byBvdmVyd3JpdGVcbiAgICAgIC8vIHRoZSBuYXZpZ2F0b3IucHJvZHVjdCBwcm9wZXJ0eS5cbiAgICAgIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudC9cIikgPiAwO1xuICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTa2lwcGluZyB0ZXN0cyBmb3IgUmVhY3QgTmF0aXZlIGluIEludGVybmV0IEV4cGxvcmVyXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JpZ2luYWxQcm9kdWN0ID0gbmF2aWdhdG9yLnByb2R1Y3Q7XG5cbiAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBqYXNtaW5lLkFqYXguaW5zdGFsbCgpO1xuICAgICAgICAvLyBTaW11bGF0ZSBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnQgdG8gZW5hYmxlIFVSSXMgYXMgaW5wdXQgb2JqZWN0cy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgXCJwcm9kdWN0XCIsIHtcbiAgICAgICAgICB2YWx1ZTogXCJSZWFjdE5hdGl2ZVwiLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBqYXNtaW5lLkFqYXgudW5pbnN0YWxsKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXZpZ2F0b3IsIFwicHJvZHVjdFwiLCB7XG4gICAgICAgICAgdmFsdWU6IG9yaWdpbmFsUHJvZHVjdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJzaG91bGQgdXBsb2FkIGEgZmlsZSBmcm9tIGFuIFVSSVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlID0ge1xuICAgICAgICAgIHVyaTogXCJmaWxlOi8vL215L2ZpbGUuZGF0XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgLy8gV2FpdCBhIHNob3J0IGludGVydmFsIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBYSFIgaGFzIGJlZW4gc2VudC5cbiAgICAgICAgYXdhaXQgd2FpdCgwKTtcblxuICAgICAgICB2YXIgcmVxID0gamFzbWluZS5BamF4LnJlcXVlc3RzLm1vc3RSZWNlbnQoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJmaWxlOi8vL215L2ZpbGUuZGF0XCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkdFVFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXNwb25zZVR5cGUpLnRvQmUoXCJibG9iXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogMTEsXG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogM1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzcG9uc2U6IG5ldyBCbG9iKFwiaGVsbG8gd29ybGRcIi5zcGxpdChcIlwiKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDExKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiL3VwbG9hZHMvYmxhcmdoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCBlbWl0IGFuIGVycm9yIGlmIGl0IGNhbid0IHJlc29sdmUgdGhlIFVSSVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlID0ge1xuICAgICAgICAgIHVyaTogXCJmaWxlOi8vL215L2ZpbGUuZGF0XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIilcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICAgIC8vIFdhaXQgYSBzaG9ydCBpbnRlcnZhbCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgWEhSIGhhcyBiZWVuIHNlbnQuXG4gICAgICAgIGF3YWl0IHdhaXQoMCk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGphc21pbmUuQWpheC5yZXF1ZXN0cy5tb3N0UmVjZW50KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiZmlsZTovLy9teS9maWxlLmRhdFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJHRVRcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVzcG9uc2VUeXBlKS50b0JlKFwiYmxvYlwiKTtcblxuICAgICAgICByZXEucmVzcG9uc2VFcnJvcigpO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuICAgICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFtvYmplY3QgT2JqZWN0XVwiKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCIjTG9jYWxTdG9yYWdlVXJsU3RvcmFnZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoXCJzaG91bGQgYWxsb3cgc3RvcmluZyBhbmQgcmV0cmlldmluZyB1cGxvYWRzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF3YWl0IGFzc2VydFVybFN0b3JhZ2UodHVzLmRlZmF1bHRPcHRpb25zLnVybFN0b3JhZ2UpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIiwiY29uc3QgeyBUZXN0SHR0cFN0YWNrLCB3YWl0YWJsZUZ1bmN0aW9uLCB3YWl0LCBnZXRCbG9iIH0gPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxzXCIpO1xuY29uc3QgdHVzID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcblxuLy8gVW5jb21tZW50IHRvIGVuYWJsZSBkZWJ1ZyBsb2cgZnJvbSB0dXMtanMtY2xpZW50XG4vL3R1cy5lbmFibGVEZWJ1Z0xvZygpO1xuXG5kZXNjcmliZShcInR1c1wiLCBmdW5jdGlvbiAoKSB7XG4gIGRlc2NyaWJlKFwiI2lzU3VwcG9ydGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpdChcInNob3VsZCBiZSB0cnVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGV4cGVjdCh0dXMuaXNTdXBwb3J0ZWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiI1VwbG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoXCJzaG91bGQgdGhyb3cgaWYgbm8gZXJyb3IgaGFuZGxlciBpcyBhdmFpbGFibGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKG51bGwpO1xuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcihcInR1czogbm8gZmlsZSBvciBzdHJlYW0gdG8gdXBsb2FkIHByb3ZpZGVkXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgdGhyb3cgaWYgbm8gZW5kcG9pbnQgYW5kIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSk7XG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKFwidHVzOiBuZWl0aGVyIGFuIGVuZHBvaW50IG9yIGFuIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB1cGxvYWQgYSBmaWxlXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEN1c3RvbTogXCJibGFyZ2hcIlxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGZvbzogXCJoZWxsb1wiLFxuICAgICAgICAgIGJhcjogXCJ3b3JsZFwiLFxuICAgICAgICAgIG5vbmxhdGluOiBcInPFgm/FhGNlXCIsXG4gICAgICAgICAgbnVtYmVyOiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKClcbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoXCJibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuICAgICAgLy9pZiAoaXNCcm93c2VyKSBleHBlY3QocmVxLndpdGhDcmVkZW50aWFscykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTWV0YWRhdGFcIl0pLnRvQmUoXCJmb28gYUdWc2JHOD0sYmFyIGQyOXliR1E9LG5vbmxhdGluIGM4V0NiOFdFWTJVPSxudW1iZXIgTVRBd1wiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSk7XG4gICAgICAvL2lmIChpc0Jyb3dzZXIpIGV4cGVjdChyZXEud2l0aENyZWRlbnRpYWxzKS50b0JlKHRydWUpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNyZWF0ZSBhbiB1cGxvYWQgaWYgcmVzdW1pbmcgZmFpbHNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIHVwbG9hZFVybDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIlxuICAgICAgfTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQwNFxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuXG4gICAgICAvLyBUaGUgdXBsb2FkIFVSTCBzaG91bGQgYmUgY2xlYXJlZCB3aGVuIHR1cy1qcy5jbGllbnQgdHJpZXMgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZC5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKG51bGwpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgY3JlYXRlIGFuIHVwbG9hZCB1c2luZyB0aGUgY3JlYXRpb24td2l0aC1kYXRhIGV4dGVuc2lvblwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IHRydWUsXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvbkNodW5rQ29tcGxldGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIilcbiAgICAgIH07XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25DaHVua0NvbXBsZXRlXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxMSk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIixcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSwgMTEpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNyZWF0ZSBhbiB1cGxvYWQgd2l0aCBwYXJ0aWFsIGRhdGEgYW5kIGNvbnRpbnVlXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIHVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgY2h1bmtTaXplOiA2LFxuICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpXG4gICAgICB9O1xuXG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uQ2h1bmtDb21wbGV0ZVwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDExKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIsXG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDZcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuXG4gICAgICAvLyBPbmNlIHRoZSBzZWNvbmQgcmVxdWVzdCBoYXMgYmVlbiBzZW50LCB0aGUgcHJvZ3Jlc3MgaGFuZGxlciBtdXN0IGhhdmUgYmVlbiBpbnZva2VkLlxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNiwgMTEpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg2LCA2LCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG5cbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoNik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDUpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiLFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTEsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgYWRkIHRoZSByZXF1ZXN0J3MgYm9keSBhbmQgSUQgdG8gZXJyb3JzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIGFkZFJlcXVlc3RJZDogdHJ1ZSxcbiAgICAgICAgcmV0cnlEZWxheXM6IG51bGwsXG4gICAgICAgIG9uRXJyb3I6IHdhaXRhYmxlRnVuY3Rpb24oXCJvbkVycm9yXCIpXG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIGNvbnN0IHJlcUlkID0gcmVxLnJlcXVlc3RIZWFkZXJzW1wiWC1SZXF1ZXN0LUlEXCJdO1xuICAgICAgZXhwZWN0KHR5cGVvZiByZXFJZCkudG9CZShcInN0cmluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXFJZC5sZW5ndGgpLnRvQmUoMzYpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgcmVzcG9uc2VUZXh0OiBcInNlcnZlcl9lcnJvclwiXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWQ7XG5cbiAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZShcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWQsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFBPU1QsIHVybDogaHR0cDovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiA1MDAsIHJlc3BvbnNlIHRleHQ6IHNlcnZlcl9lcnJvciwgcmVxdWVzdCBpZDogXCIgKyByZXFJZCArIFwiKVwiKTtcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXF1ZXN0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlc3BvbnNlKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaW52b2tlIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBjYWxsYmFja3NcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2Zvb1wiLFxuICAgICAgICBvbkJlZm9yZVJlcXVlc3Q6IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2Zvb1wiKTtcbiAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKFwiSEVBRFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BZnRlclJlc3BvbnNlOiBmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2Zvb1wiKTtcbiAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKFwiSEVBRFwiKTtcbiAgICAgICAgICBleHBlY3QocmVzLmdldFN0YXR1cygpKS50b0JlKDIwNCk7XG4gICAgICAgICAgZXhwZWN0KHJlcy5nZXRIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIpKS50b0JlKDExKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpXG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkJlZm9yZVJlcXVlc3RcIik7XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uQWZ0ZXJSZXNwb25zZVwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMSxcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQWZ0ZXJSZXNwb25zZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgcmVzdW1pbmcgZmFpbHMgYW5kIG5vIGVuZHBvaW50IGlzIHByb3ZpZGVkXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgdXBsb2FkVXJsOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZ1wiLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDRcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZDtcbiAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZShcInR1czogdW5hYmxlIHRvIHJlc3VtZSB1cGxvYWQgKG5ldyB1cGxvYWQgY2Fubm90IGJlIGNyZWF0ZWQgd2l0aG91dCBhbiBlbmRwb2ludCksIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IEhFQUQsIHVybDogaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nLCByZXNwb25zZSBjb2RlOiA0MDQsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKVwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgVVJMc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW86MTA4MC9maWxlcy9cIlxuICAgICAgfTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pbzoxMDgwL2ZpbGVzL1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjogXCIvL2xvY2FsaG9zdC91cGxvYWRzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL2xvY2FsaG9zdC91cGxvYWRzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL2xvY2FsaG9zdC91cGxvYWRzL2Zvb1wiKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHVwbG9hZCBhIGZpbGUgaW4gY2h1bmtzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIGNodW5rU2l6ZTogNyxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpLFxuICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25DaHVua0NvbXBsZXRlXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL3VwbG9hZHMvYmxhcmdoXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNyk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogN1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDcpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg0KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNywgNywgMTEpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg0LCAxMSwgMTEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgYWRkIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHRvIGVycm9yc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICByZXRyeURlbGF5czogbnVsbCxcbiAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIilcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgQ3VzdG9tOiBcImJsYXJnaFwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUobnVsbCk7XG4gICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogNTAwLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSlcIik7XG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVxdWVzdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXNwb25zZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXNwb25zZS5nZXRIZWFkZXIoXCJDdXN0b21cIikpLnRvQmUoXCJibGFyZ2hcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBvbmx5IGNyZWF0ZSBhbiB1cGxvYWQgZm9yIGVtcHR5IGZpbGVzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIilcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDApO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJMb2NhdGlvblwiOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9lbXB0eVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBub3QgcmVzdW1lIGEgZmluaXNoZWQgdXBsb2FkXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIiksXG4gICAgICAgIHVwbG9hZFVybDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIlxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiBcIjExXCIsXG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IFwiMTFcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmVzdW1lIGFuIHVwbG9hZCBmcm9tIGEgc3BlY2lmaWVkIHVybFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIixcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKSxcbiAgICAgICAgZmluZ2VycHJpbnQ6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJmaW5nZXJwcmludFwiKS5hbmQucmVzb2x2ZVRvKFwiZmluZ2VycHJpbnRlZFwiKTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExLFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSAtIDMpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXN1bWUgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgdXBsb2FkXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICB1cGxvYWQuYWJvcnQoKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNSxcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgb3ZlcnJpZGUgdGhlIFBBVENIIG1ldGhvZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIixcbiAgICAgICAgb3ZlcnJpZGVQYXRjaE1ldGhvZDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExLFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiWC1IVFRQLU1ldGhvZC1PdmVycmlkZVwiXSkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZW1pdCBhbiBlcnJvciBpZiBhbiB1cGxvYWQgaXMgbG9ja2VkXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIHVwbG9hZFVybDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZFwiLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKSxcbiAgICAgICAgcmV0cnlEZWxheXM6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDIzIC8vIExvY2tlZFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3IEVycm9yKFwidHVzOiB1cGxvYWQgaXMgY3VycmVudGx5IGxvY2tlZDsgcmV0cnkgbGF0ZXIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IEhFQUQsIHVybDogaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQsIHJlc3BvbnNlIGNvZGU6IDQyMywgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpXCIpKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGVtaXQgYW4gZXJyb3IgaWYgbm8gTG9jYXRpb24gaGVhZGVyIGlzIHByZXNlbnRlZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKSxcbiAgICAgICAgcmV0cnlEZWxheXM6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICAvLyBUaGUgTG9jYXRpb24gaGVhZGVyIGlzIG9taXR0ZWQgb24gcHVycG9zZSBoZXJlXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXcgRXJyb3IoXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFBPU1QsIHVybDogaHR0cDovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiAyMDEsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKVwiKSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB0aHJvdyBpZiByZXRyeURlbGF5cyBpcyBub3QgYW4gYXJyYXlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwge1xuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vZW5kcG9pbnQvXCIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiA0NFxuICAgICAgfSk7XG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKFwidHVzOiB0aGUgYHJldHJ5RGVsYXlzYCBvcHRpb24gbXVzdCBlaXRoZXIgYmUgYW4gYXJyYXkgb3IgbnVsbFwiKTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgdGVzdHMgZW5zdXJlcyB0aGF0IHR1cy1qcy1jbGllbnQgY29ycmVjdGx5IHJldHJpZXMgaWYgdGhlXG4gICAgLy8gcmVzcG9uc2UgaGFzIHRoZSBjb2RlIDUwMCBJbnRlcm5hbCBFcnJvciwgNDIzIExvY2tlZCBvciA0MDkgQ29uZmxpY3QuXG4gICAgaXQoXCJzaG91bGQgcmV0cnkgdGhlIHVwbG9hZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyM1xuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAwLFxuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDlcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMCxcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIC8vIFRoaXMgdGVzdHMgZW5zdXJlcyB0aGF0IHR1cy1qcy1jbGllbnQgY29ycmVjdGx5IHJldHJpZXMgaWYgdGhlXG4gICAgLy8gcmV0dXJuIHZhbHVlIG9mIG9uU2hvdWxkUmV0cnkgaXMgdHJ1ZS5cbiAgICBpdChcInNob3VsZCByZXRyeSB0aGUgdXBsb2FkIHdoZW4gb25TaG91bGRSZXRyeSBzcGVjaWZpZWQgYW5kIHJldHVybnMgdHJ1ZVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKSxcbiAgICAgICAgb25TaG91bGRSZXRyeTogKCkgPT4gdHJ1ZVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvblNob3VsZFJldHJ5XCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuICAgICAgc3B5T24odHVzLlVwbG9hZC5wcm90b3R5cGUsIFwiX2VtaXRFcnJvclwiKS5hbmQuY2FsbFRocm91Z2goKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyM1xuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAwLFxuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDlcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMCxcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgbGV0IGVycm9yID0gdXBsb2FkLl9lbWl0RXJyb3IuY2FsbHMuYXJnc0ZvcigwKVswXTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU2hvdWxkUmV0cnkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU2hvdWxkUmV0cnkuY2FsbHMuYXJnc0ZvcigwKSkudG9FcXVhbChbZXJyb3IsIDAsIHVwbG9hZC5vcHRpb25zXSk7XG4gICAgICBlcnJvciA9IHVwbG9hZC5fZW1pdEVycm9yLmNhbGxzLmFyZ3NGb3IoMSlbMF07XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblNob3VsZFJldHJ5LmNhbGxzLmFyZ3NGb3IoMSkpLnRvRXF1YWwoW2Vycm9yLCAxLCB1cGxvYWQub3B0aW9uc10pO1xuICAgIH0pO1xuXG4gICAgLy8gVGhpcyB0ZXN0cyBlbnN1cmVzIHRoYXQgdHVzLWpzLWNsaWVudCBjb3JyZWN0bHkgYWJvcnRzIGlmIHRoZVxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBvblNob3VsZFJldHJ5IGlzIGZhbHNlLlxuICAgIGl0KFwic2hvdWxkIG5vdCByZXRyeSB0aGUgdXBsb2FkIHdoZW4gY2FsbGJhY2sgc3BlY2lmaWVkIGFuZCByZXR1cm5zIGZhbHNlXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKSxcbiAgICAgICAgb25TaG91bGRSZXRyeTogKCkgPT4gZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICAvLyBUaGUgZXJyb3IgY2FsbGJhY2sgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciB0aGUgZmlyc3QgZXJyb3IgcmVzcG9uc2UuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBub3QgcmV0cnkgaWYgdGhlIGVycm9yIGhhcyBub3QgYmVlbiBjYXVzZWQgYnkgYSByZXF1ZXN0XCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogbmV3IFRlc3RIdHRwU3RhY2soKSxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25TdWNjZXNzXCIpO1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkVycm9yXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICBzcHlPbih1cGxvYWQsIFwiX2NyZWF0ZVVwbG9hZFwiKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBhd2FpdCB3YWl0KDIwMCk7XG5cbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcImN1c3RvbSBlcnJvclwiKTtcbiAgICAgIHVwbG9hZC5fZW1pdEVycm9yKGVycm9yKTtcblxuICAgICAgZXhwZWN0KHVwbG9hZC5fY3JlYXRlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvcik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzdG9wIHJldHJ5aW5nIGFmdGVyIGFsbCBkZWxheXMgaGF2ZSBiZWVuIHVzZWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIilcbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uU3VjY2Vzc1wiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICAvLyBUaGUgZXJyb3IgY2FsbGJhY2sgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciB0aGUgZmlyc3QgZXJyb3IgcmVzcG9uc2UuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzdG9wIHJldHJ5aW5nIHdoZW4gdGhlIGFib3J0IGZ1bmN0aW9uIGlzIGNhbGxlZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTBdLFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkVycm9yXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICBzcHlPbih1cGxvYWQsIFwic3RhcnRcIikuYW5kLmNhbGxUaHJvdWdoKCk7XG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpLFxuICAgICAgICB3YWl0KDEwMClcbiAgICAgIF0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwidGltZWQgb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgc3RvcCB1cGxvYWQgd2hlbiB0aGUgYWJvcnQgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgY2h1bmtTaXplOiA1LFxuICAgICAgICBvbkNodW5rQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkNodW5rQ29tcGxldGVcIikuYW5kLmNhbGxUaHJvdWdoKCk7XG5cbiAgICAgIGxldCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpLFxuICAgICAgICB3YWl0KDIwMClcbiAgICAgIF0pO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJ0aW1lZCBvdXRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzdG9wIHVwbG9hZCB3aGVuIHRoZSBhYm9ydCBmdW5jdGlvbiBpcyBjYWxsZWQgZHVyaW5nIHRoZSBQT1NUIHJlcXVlc3RcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkVycm9yXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICB1cGxvYWQuYWJvcnQoKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCksXG4gICAgICAgIHdhaXQoMjAwKVxuICAgICAgXSk7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwidGltZWQgb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZiBhbiB1cGxvYWQgcHJvY2VlZHNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25FcnJvclwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCIvZmlsZXMvZm9vXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDAsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDUsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIiwiY29uc3QgeyBnZXRCbG9iIH0gPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxzXCIpO1xuY29uc3QgdHVzID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xuXG4vLyBUZXN0IHRpbWVvdXQgZm9yIGVuZC10by1lbmQgdGVzdHMgd2hlbiB1cGxvYWRpbmcgdG8gcmVhbCBzZXJ2ZXIuXG5jb25zdCBFTkRfVE9fRU5EX1RJTUVPVVQgPSAyMCAqIDEwMDA7XG5cbmRlc2NyaWJlKFwidHVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgZGVzY3JpYmUoXCJlbmQtdG8tZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpdChcInNob3VsZCB1cGxvYWQgdG8gYSByZWFsIHR1cyBzZXJ2ZXJcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vbWFzdGVyLnR1cy5pby9maWxlcy9cIixcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbm9ubGF0aW46IFwic8WCb8WEY2VcIixcbiAgICAgICAgICAgIG51bWJlcjogMTAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6IFwiaGVsbG8udHh0XCIsXG4gICAgICAgICAgICBmaWxldHlwZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvTWF0Y2goL15odHRwczpcXC9cXC9tYXN0ZXJcXC50dXNcXC5pb1xcL2ZpbGVzXFwvLyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwbG9hZCBVUkw6XCIsIHVwbG9hZC51cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG4gICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZENvbnRlbnQpXG4gICAgICAgIC50aGVuKCh1cGxvYWQpID0+IHtcbiAgICAgICAgICByZXR1cm4gdXBsb2FkLmFib3J0KHRydWUpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1cGxvYWQpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZERlbGV0aW9uKTtcbiAgICB9LCBFTkRfVE9fRU5EX1RJTUVPVVQpO1xuXG4gICAgaXQoXCJzaG91bGQgdXBsb2FkIHRvIGEgcmVhbCB0dXMgc2VydmVyIHdpdGggY3JlYXRpb24td2l0aC11cGxvYWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vbWFzdGVyLnR1cy5pby9maWxlcy9cIixcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbm9ubGF0aW46IFwic8WCb8WEY2VcIixcbiAgICAgICAgICAgIG51bWJlcjogMTAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6IFwiaGVsbG8udHh0XCIsXG4gICAgICAgICAgICBmaWxldHlwZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvTWF0Y2goL15odHRwczpcXC9cXC9tYXN0ZXJcXC50dXNcXC5pb1xcL2ZpbGVzXFwvLyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwbG9hZCBVUkw6XCIsIHVwbG9hZC51cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG4gICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZENvbnRlbnQpO1xuICAgIH0sIEVORF9UT19FTkRfVElNRU9VVCk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVXBsb2FkQ29udGVudCh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmdldCh1cGxvYWQudXJsKVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzLmRhdGEpLnRvQmUoXCJoZWxsbyB3b3JsZFwiKTtcblxuICAgICAgcmV0dXJuIHZhbGlkYXRlVXBsb2FkTWV0YWRhdGEodXBsb2FkKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWRNZXRhZGF0YSh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmhlYWQodXBsb2FkLnVybCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiVHVzLVJlc3VtYWJsZVwiOiBcIjEuMC4wXCJcbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgZXhwZWN0KHJlcy5kYXRhKS50b0JlKFwiXCIpO1xuICAgIGV4cGVjdChyZXMuaGVhZGVyc1tcInR1cy1yZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICBleHBlY3QocmVzLmhlYWRlcnNbXCJ1cGxvYWQtb2Zmc2V0XCJdKS50b0JlKFwiMTFcIik7XG4gICAgZXhwZWN0KHJlcy5oZWFkZXJzW1widXBsb2FkLWxlbmd0aFwiXSkudG9CZShcIjExXCIpO1xuXG4gICAgLy8gVGhlIHZhbHVlcyBpbiB0aGUgVXBsb2FkLU1ldGFkYXRhIGhlYWRlciBtYXkgbm90IGJlIGluIHRoZSBzYW1lXG4gICAgLy8gb3JkZXIgYXMgd2Ugc3VibWl0dGVkIHRoZW0gKHRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmVcbiAgICAvLyB0aGF0KS4gVGhlcmVmb3JlLCB3ZSBzcGxpdCB0aGUgdmFsdWVzIGFuZCB2ZXJpZnkgdGhhdCBlYWNoIG9uZVxuICAgIC8vIGlzIHByZXNlbnQuXG4gICAgdmFyIG1ldGFkYXRhU3RyID0gcmVzLmhlYWRlcnNbXCJ1cGxvYWQtbWV0YWRhdGFcIl07XG4gICAgZXhwZWN0KG1ldGFkYXRhU3RyKS50b0JlVHJ1dGh5KCk7XG4gICAgdmFyIG1ldGFkYXRhID0gbWV0YWRhdGFTdHIuc3BsaXQoXCIsXCIpO1xuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKFwiZmlsZW5hbWUgYUdWc2JHOHVkSGgwXCIpO1xuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKFwiZmlsZXR5cGUgZEdWNGRDOXdiR0ZwYmc9PVwiKTtcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQ29udGFpbihcIm5vbmxhdGluIGM4V0NiOFdFWTJVPVwiKTtcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQ29udGFpbihcIm51bWJlciBNVEF3XCIpO1xuICAgIGV4cGVjdChtZXRhZGF0YS5sZW5ndGgpLnRvQmUoNCk7XG5cbiAgICByZXR1cm4gdXBsb2FkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWREZWxldGlvbih1cGxvYWQpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPT09IDQwNDtcbiAgfTtcblxuICByZXR1cm4gYXhpb3MuZ2V0KHVwbG9hZC51cmwsIHsgdmFsaWRhdGVTdGF0dXM6IHZhbGlkYXRlU3RhdHVzIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgZXhwZWN0KHJlcy5zdGF0dXMpLnRvQmUoNDA0KTtcblxuICAgICAgcmV0dXJuIHVwbG9hZDtcbiAgICB9KTtcbn1cbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgd2FpdCwgZ2V0QmxvYiB9ID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsc1wiKTtcbmNvbnN0IHR1cyA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5cbmRlc2NyaWJlKFwidHVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgZGVzY3JpYmUoXCJwYXJhbGxlbCB1cGxvYWRpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIGl0KFwic2hvdWxkIHRocm93IGlmIGluY29tcGF0aWJsZSBvcHRpb25zIGFyZSB1c2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIHtcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHVwbG9hZFVybDogXCJmb29cIlxuICAgICAgfSk7XG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKFwidHVzOiBjYW5ub3QgdXNlIHRoZSB1cGxvYWRVcmwgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGVuYWJsZWRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzcGxpdCBhIGZpbGUgaW50byBtdWx0aXBsZSBwYXJ0cyBhbmQgY3JlYXRlIGFuIHVwbG9hZCBmb3IgZWFjaFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuXG4gICAgICBjb25zdCB0ZXN0VXJsU3RvcmFnZSA9IHtcbiAgICAgICAgYWRkVXBsb2FkOiAoZmluZ2VycHJpbnQsIHVwbG9hZCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChmaW5nZXJwcmludCkudG9CZShcImZpbmdlcnByaW50ZWRcIik7XG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC51cGxvYWRVcmwpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnNpemUpLnRvQmUoMTEpO1xuICAgICAgICAgIGV4cGVjdCh1cGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzKS50b0VxdWFsKFtcbiAgICAgICAgICAgIFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCIsXG4gICAgICAgICAgICBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwidHVzOjpmaW5nZXJwcmludGVkOjoxMzM3XCIpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVVcGxvYWQ6ICh1cmxTdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVybFN0b3JhZ2VLZXkpLnRvQmUoXCJ0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzdcIik7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsIFwicmVtb3ZlVXBsb2FkXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsIFwiYWRkVXBsb2FkXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2U6IHRlc3RVcmxTdG9yYWdlLFxuICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiB0cnVlLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbIDEwIF0sXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEN1c3RvbTogXCJibGFyZ2hcIlxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGZvbzogXCJoZWxsb1wiXG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oKSxcbiAgICAgICAgZmluZ2VycHJpbnQ6ICgpID0+IFByb21pc2UucmVzb2x2ZShcImZpbmdlcnByaW50ZWRcIilcbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDUpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJwYXJ0aWFsXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoXCJibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoNik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUNvbmNhdFwiXSkudG9CZShcInBhcnRpYWxcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU1ldGFkYXRhXCJdKS50b0JlVW5kZWZpbmVkKCk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDJcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG5cbiAgICAgIC8vIEFzc2VydCB0aGF0IHRoZSBVUkxzIGhhdmUgYmVlbiBzdG9yZWQuXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UuYWRkVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDJcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoXCJibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpO1xuXG4gICAgICAvLyBSZXR1cm4gYW4gZXJyb3IgdG8gZW5zdXJlIHRoYXQgdGhlIGluZGl2aWR1YWwgcGFydGlhbCB1cGxvYWQgaXMgcHJvcGVybHkgcmV0cmllZC5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZShcImJsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZShcImJsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZShcImZvbyBhR1ZzYkc4PVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLnJlbW92ZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZW1pdCBlcnJvciBmcm9tIGEgcGFydGlhbCB1cGxvYWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAyLFxuICAgICAgICByZXRyeURlbGF5czogbnVsbCxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDUpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogUE9TVCwgdXJsOiBodHRwczovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiA1MDAsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKVwiKTtcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXF1ZXN0KS50b0JlKHJlcSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXN1bWUgdGhlIHBhcnRpYWwgdXBsb2Fkc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAvLyBUaGUgY2xpZW50IHNob3VsZCByZXN1bWUgdGhlIHBhcmFsbGVsIHVwbG9hZHMsIGV2ZW4gaWYgaXQgaXMgbm90XG4gICAgICAgIC8vIGNvbmZpZ3VyZWQgZm9yIG5ldyB1cGxvYWRzLlxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbigpXG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvblByb2dyZXNzXCIpO1xuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcblxuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZCh7XG4gICAgICAgIHVybFN0b3JhZ2VLZXk6IFwidHVzOjpmaW5nZXJwcmludDo6MTMzN1wiLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZFVybHM6IFtcbiAgICAgICAgICBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMVwiLFxuICAgICAgICAgIFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCJcbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMVwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiA1LFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDYsXG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDFcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMyk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtQ29uY2F0XCJdKS50b0JlKFwiZmluYWw7aHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxIGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgYWJvcnQgYWxsIHBhcnRpYWwgdXBsb2FkcyBhbmQgcmVzdW1lIGZyb20gdGhlbVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFwiZmluZ2VycHJpbnRlZFwiKVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDUpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJwYXJ0aWFsXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDYpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJwYXJ0aWFsXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcTEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXExLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMVwiKTtcbiAgICAgIGV4cGVjdChyZXExLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcTEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxMS5ib2R5LnNpemUpLnRvQmUoNSk7XG5cbiAgICAgIGNvbnN0IHJlcTIgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEyLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEyLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcTIucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxMi5ib2R5LnNpemUpLnRvQmUoNik7XG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpO1xuXG4gICAgICByZXExLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEyLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBObyBmdXJ0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSBzZW50LlxuICAgICAgY29uc3QgcmVxUHJvbWlzZSA9IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcmVxUHJvbWlzZSxcbiAgICAgICAgd2FpdCgxMDApXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJ0aW1lZCBvdXRcIik7XG5cbiAgICAgIC8vIFJlc3RhcnQgdGhlIHVwbG9hZFxuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIC8vIFJldXNlIHRoZSBwcm9taXNlIGZyb20gYmVmb3JlIGFzIGl0IGlzIG5vdCBjYW5jZWxsZWQuXG4gICAgICByZXEgPSBhd2FpdCByZXFQcm9taXNlO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDFcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogNSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiA2LFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJMb2NhdGlvblwiOiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkM1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkM1wiKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7IiwiLyogZ2xvYmFsIGV4cGVjdEFzeW5jICovXG5jb25zdCB7IFRlc3RIdHRwU3RhY2ssIGdldEJsb2IgfSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbHNcIik7XG5jb25zdCB0dXMgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuXG5kZXNjcmliZShcInR1c1wiLCBmdW5jdGlvbiAoKSB7XG4gIGRlc2NyaWJlKFwidGVybWluYXRlIHVwbG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoXCJzaG91bGQgdGVybWluYXRlIHVwbG9hZCB3aGVuIGFib3J0IGlzIGNhbGxlZCB3aXRoIHRydWVcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGFib3J0UHJvbWlzZTtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgY2h1bmtTaXplOiA1LFxuICAgICAgICBvbkNodW5rQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhYm9ydFByb21pc2UgPSB1cGxvYWQuYWJvcnQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25DaHVua0NvbXBsZXRlXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiREVMRVRFXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgYXdhaXQgYWJvcnRQcm9taXNlO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmV0cnkgdGVybWluYXRlIHdoZW4gYW4gZXJyb3IgaXMgcmV0dXJuZWQgb24gZmlyc3QgdHJ5XCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBhYm9ydFByb21pc2U7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgIGNodW5rU2l6ZTogNSxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYWJvcnRQcm9taXNlID0gdXBsb2FkLmFib3J0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uQ2h1bmtDb21wbGV0ZVwiKS5hbmQuY2FsbFRocm91Z2goKTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MjNcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDRcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhYm9ydFByb21pc2U7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHN0b3AgcmV0cnlpbmcgd2hlbiBhbGwgZGVsYXlzIGFyZSB1c2VkIHVwXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdGVybWluYXRlUHJvbWlzZSA9IHR1cy5VcGxvYWQudGVybWluYXRlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIiwgb3B0aW9ucyk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3RBc3luYyh0ZXJtaW5hdGVQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoL3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB0ZXJtaW5hdGluZyB1cGxvYWQvKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGludm9rZSB0aGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgUHJvbWlzZXNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgb25CZWZvcmVSZXF1ZXN0OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHJlcS5nZXRVUkwoKSkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb29cIik7XG4gICAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKFwiREVMRVRFXCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkFmdGVyUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChyZXEuZ2V0VVJMKCkpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vXCIpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZShcIkRFTEVURVwiKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXMuZ2V0U3RhdHVzKCkpLnRvQmUoMjA0KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25CZWZvcmVSZXF1ZXN0XCIpO1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkFmdGVyUmVzcG9uc2VcIik7XG5cbiAgICAgIGNvbnN0IHRlcm1pbmF0ZVByb21pc2UgPSB0dXMuVXBsb2FkLnRlcm1pbmF0ZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb29cIiwgb3B0aW9ucyk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiREVMRVRFXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKHRlcm1pbmF0ZVByb21pc2UpLnRvQmVSZXNvbHZlZCgpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25CZWZvcmVSZXF1ZXN0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdfQ==
